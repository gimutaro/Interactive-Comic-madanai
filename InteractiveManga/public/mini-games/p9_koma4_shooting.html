<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wire Art Shooting - Amusement Park</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;300;400&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            font-weight: 100;
            background: #ffffff;
            cursor: crosshair;
        }
        
        #gameCanvas {
            display: block;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.8;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background-color: #000;
        }
        
        #crosshair::before {
            width: 100%;
            height: 1px;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }
        
        #crosshair::after {
            width: 1px;
            height: 100%;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #crosshair .circle {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 1px solid #000;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        #ui {
            position: absolute;
            top: 30px;
            left: 30px;
            color: #000;
            font-size: 14px;
            font-weight: 300;
            letter-spacing: 2px;
            z-index: 10;
            line-height: 1.4;
        }
        
        #ui .label {
            font-weight: 100;
            opacity: 0.6;
            font-size: 12px;
        }
        
        #ui .value {
            font-size: 24px;
            margin-top: 5px;
            margin-bottom: 10px;
            font-weight: 400;
        }
        
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
            color: #000;
            padding: 60px;
            font-size: 48px;
            font-weight: 100;
            letter-spacing: 8px;
            display: none;
            z-index: 20;
            text-align: center;
            text-transform: uppercase;
            line-height: 1.5;
            border: 1px solid #000;
            box-shadow: 0 0 50px rgba(0,0,0,0.1);
        }
        
        #instructions {
            position: absolute;
            bottom: 30px;
            right: 30px;
            color: #000;
            text-align: right;
            z-index: 10;
            font-size: 12px;
            opacity: 0.6;
            font-weight: 300;
            letter-spacing: 1px;
        }
        
        #lockPrompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
            color: #000;
            padding: 60px;
            font-size: 16px;
            z-index: 20;
            text-align: center;
            border: 1px solid #000;
            box-shadow: 0 0 50px rgba(0,0,0,0.1);
        }
        
        #lockPrompt h1 {
            margin: 0 0 10px 0;
            font-weight: 100;
            font-size: 36px;
            letter-spacing: 4px;
        }
        
        #lockPrompt small {
            opacity: 0.6;
            letter-spacing: 1px;
        }
        
        #lockPrompt button {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 14px;
            background: #000;
            color: #fff;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Inter', sans-serif;
            font-weight: 300;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        
        /* hover効果を削除 */
        
        .hit-marker {
            position: absolute;
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 5;
        }
        
        .hit-marker::before,
        .hit-marker::after {
            content: '';
            position: absolute;
            background: #000;
            animation: hitFade 0.5s ease-out forwards;
        }
        
        .hit-marker::before {
            width: 100%;
            height: 1px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .hit-marker::after {
            width: 1px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        
        @keyframes hitFade {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(2); }
        }

        
    </style>
</head>
<body>
    <div id="crosshair">
        <div class="circle"></div>
    </div>
    <div id="ui">
        <div>
            <div class="label">TARGETS HIT</div>
            <div class="value"><span id="score">0</span>/20</div>
        </div>
        <div style="margin-top: 20px;">
            <div class="label">TIME</div>
            <div class="value"><span id="timer">00:00</span></div>
        </div>
    </div>
    <div id="message"></div>
    <div id="instructions">
        WASD — MOVE&nbsp;&nbsp;&nbsp;&nbsp;QE — TURN&nbsp;&nbsp;&nbsp;&nbsp;SPACE — JUMP&nbsp;&nbsp;&nbsp;&nbsp;CLICK — SHOOT
    </div>
    <div id="lockPrompt">
        <h1>WIRE ART SHOOTING</h1>
        <small>DESTROY ALL 20 TARGETS</small><br><br>
        <button id="startButton">START GAME</button>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ゲーム変数
        let scene, camera, renderer;
        let targets = [];
        let bullets = [];
        let particles = [];
        let buildings = []; // 建物の衝突判定用
        let score = 0;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let isLocked = false;
        let pitchObject, yawObject;
        let usePointerLock = true;
        let prevMouseX = 0, prevMouseY = 0;
        let totalYawRotation = 0;
        let totalPitchRotation = 0;
        let turnLeft = false;
        let turnRight = false;
        let lastMouseEvent = null;
        
        // タイマー関連の変数
        let startTime = null;
        let elapsedTime = 0;
        let timerInterval = null;
        let isGameRunning = false;
        
        // 遊園地用の変数
        let animatedObjects = {
            ferrisWheel: null,
            merryGoRound: null,
            rollerCoaster: null,
            swingRide: null,
            freeFall: null,
            vikingShip: null,
            teacups: null,
            goKarts: null,
            trainTrack: null,
            constellations: null,
            pendulumRide: null,
            clockTower: null
        };

        // Material presets
        const materials = {
            black: () => new THREE.MeshPhongMaterial({ color: 0x000000, wireframe: true }),
            darkGray: () => new THREE.MeshPhongMaterial({ color: 0x222222, wireframe: true }),
            gray: () => new THREE.MeshPhongMaterial({ color: 0x333333, wireframe: true }),
            mediumGray: () => new THREE.MeshPhongMaterial({ color: 0x444444, wireframe: true }),
            lightGray: () => new THREE.MeshPhongMaterial({ color: 0x555555, wireframe: true }),
            veryLightGray: () => new THREE.MeshPhongMaterial({ color: 0x666666, wireframe: true }),
            gold: () => new THREE.MeshPhongMaterial({ color: 0x888844, wireframe: true }),
            transparent: (color, opacity) => new THREE.MeshPhongMaterial({ 
                color: color || 0x444444, 
                wireframe: true, 
                transparent: true, 
                opacity: opacity || 0.5 
            }),
            transparentNoFog: (color, opacity) => new THREE.MeshPhongMaterial({ 
                color: color || 0x444444, 
                wireframe: true, 
                transparent: true, 
                opacity: opacity || 0.5,
                fog: false  // フォグの影響を受けない
            }),
            line: (color, opacity) => new THREE.LineBasicMaterial({ 
                color: color || 0x555555, 
                transparent: opacity !== undefined, 
                opacity: opacity || 1 
            }),
            lineNoFog: (color, opacity) => new THREE.LineBasicMaterial({ 
                color: color || 0x555555, 
                transparent: opacity !== undefined, 
                opacity: opacity || 1,
                fog: false  // フォグの影響を受けない
            })
        };

        // Helper functions
        const helpers = {
            createCylinder: (radiusTop, radiusBottom, height, material) => {
                const geometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height);
                return new THREE.Mesh(geometry, material || materials.gray());
            },
            
            createBox: (width, height, depth, material) => {
                const geometry = new THREE.BoxGeometry(width, height, depth);
                return new THREE.Mesh(geometry, material || materials.gray());
            },
            
            createSphere: (radius, widthSegments, heightSegments, material) => {
                const geometry = new THREE.SphereGeometry(radius, widthSegments || 8, heightSegments || 8);
                return new THREE.Mesh(geometry, material || materials.gray());
            },
            
            createTorus: (radius, tube, radialSegments, tubularSegments, arc, material) => {
                const geometry = new THREE.TorusGeometry(radius, tube, radialSegments || 8, tubularSegments || 32, arc);
                return new THREE.Mesh(geometry, material || materials.gray());
            },
            
            createLine: (points, material) => {
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                return new THREE.Line(geometry, material || materials.line());
            }
        }

        // ペンデュラムライド（振り子）
        function createPendulumRide() {
            const group = new THREE.Group();
            
            // 基盤構造
            const foundation = helpers.createBox(14, 2.5, 14, materials.darkGray());
            foundation.position.y = 1.25;
            group.add(foundation);
            
            // A型フレーム支柱（左側）
            const leftFrame = new THREE.Group();
            
            // 左手前の支柱（八の字型にするため内側に傾ける）
            const leftPillar1 = helpers.createCylinder(1.1, 1.1, 30, materials.mediumGray());
            leftPillar1.position.set(-3.5, 15, -9);  
            leftPillar1.rotation.z = -0.15;  // 内側（右）に傾ける
            
            // 左奥の支柱（八の字型にするため内側に傾ける）
            const leftPillar2 = helpers.createCylinder(1.1, 1.1, 30, materials.mediumGray());
            leftPillar2.position.set(-3.5, 15, 9);   
            leftPillar2.rotation.z = -0.15;  // 内側（右）に傾ける
            
            const leftCrossBeam = helpers.createCylinder(0.6, 0.6, 18, materials.lightGray());  
            leftCrossBeam.position.set(-3.5, 24, 0);
            leftCrossBeam.rotation.x = Math.PI / 2;
            
            leftFrame.add(leftPillar1);
            leftFrame.add(leftPillar2);
            leftFrame.add(leftCrossBeam);
            leftFrame.position.x = -3.5;
            group.add(leftFrame);
            
            // A型フレーム支柱（右側）
            const rightFrame = new THREE.Group();
            
            // 右手前の支柱（八の字型にするため内側に傾ける）
            const rightPillar1 = helpers.createCylinder(1.1, 1.1, 30, materials.mediumGray());
            rightPillar1.position.set(3.5, 15, -9);  
            rightPillar1.rotation.z = 0.15;  // 内側（左）に傾ける
            
            // 右奥の支柱（八の字型にするため内側に傾ける）
            const rightPillar2 = helpers.createCylinder(1.1, 1.1, 30, materials.mediumGray());
            rightPillar2.position.set(3.5, 15, 9);   
            rightPillar2.rotation.z = 0.15;  // 内側（左）に傾ける
            
            const rightCrossBeam = helpers.createCylinder(0.6, 0.6, 18, materials.lightGray());  
            rightCrossBeam.position.set(3.5, 24, 0);
            rightCrossBeam.rotation.x = Math.PI / 2;
            
            rightFrame.add(rightPillar1);
            rightFrame.add(rightPillar2);
            rightFrame.add(rightCrossBeam);
            rightFrame.position.x = 3.5;
            group.add(rightFrame);
            
            // 追加の補強構造
            // 左側前後の対角補強
            const leftDiagonalFront = helpers.createCylinder(0.35, 0.35, 12, materials.lightGray());
            leftDiagonalFront.position.set(-7, 12, -9);  
            leftDiagonalFront.rotation.z = -0.3;
            group.add(leftDiagonalFront);
            
            const leftDiagonalBack = helpers.createCylinder(0.35, 0.35, 12, materials.lightGray());
            leftDiagonalBack.position.set(-7, 12, 9);  
            leftDiagonalBack.rotation.z = -0.3;
            group.add(leftDiagonalBack);
            
            // 右側前後の対角補強
            const rightDiagonalFront = helpers.createCylinder(0.35, 0.35, 12, materials.lightGray());
            rightDiagonalFront.position.set(7, 12, -9);  
            rightDiagonalFront.rotation.z = 0.3;
            group.add(rightDiagonalFront);
            
            const rightDiagonalBack = helpers.createCylinder(0.35, 0.35, 12, materials.lightGray());
            rightDiagonalBack.position.set(7, 12, 9);  
            rightDiagonalBack.rotation.z = 0.3;
            group.add(rightDiagonalBack);
            
            // 前後の水平補強
            const frontBrace = helpers.createCylinder(0.45, 0.45, 14, materials.lightGray());
            frontBrace.position.set(0, 18, -9);  
            frontBrace.rotation.z = Math.PI / 2;
            group.add(frontBrace);
            
            const backBrace = helpers.createCylinder(0.45, 0.45, 14, materials.lightGray());
            backBrace.position.set(0, 18, 9);  
            backBrace.rotation.z = Math.PI / 2;
            group.add(backBrace);
            
            // メイン回転軸
            const mainAxis = helpers.createCylinder(0.9, 0.9, 14, materials.black());
            mainAxis.rotation.z = Math.PI / 2;
            mainAxis.position.y = 24;
            group.add(mainAxis);
            
            // 振り子アーム構造
            const pendulumArm = new THREE.Group();
            
            // メインアーム（2本の平行な棒）
            const armBar1 = helpers.createCylinder(0.45, 0.45, 22, materials.mediumGray());
            armBar1.position.set(0, -11, -0.6);
            pendulumArm.add(armBar1);
            
            const armBar2 = helpers.createCylinder(0.45, 0.45, 22, materials.mediumGray());
            armBar2.position.set(0, -11, 0.6);
            pendulumArm.add(armBar2);
            
            // アームの補強（X字のクロスブレース）
            for (let i = 0; i < 4; i++) {
                const crossBrace1 = helpers.createCylinder(0.18, 0.18, 1.8, materials.lightGray());
                crossBrace1.position.set(0, -3.5 - i * 4.5, 0);
                crossBrace1.rotation.x = Math.PI / 4;
                pendulumArm.add(crossBrace1);
                
                const crossBrace2 = helpers.createCylinder(0.18, 0.18, 1.8, materials.lightGray());
                crossBrace2.position.set(0, -3.5 - i * 4.5, 0);
                crossBrace2.rotation.x = -Math.PI / 4;
                pendulumArm.add(crossBrace2);
            }
            
            // 座席プラットフォーム（回転する円形）
            const seatPlatform = new THREE.Group();
            
            // プラットフォームベース
            const platformBase = helpers.createCylinder(7, 7, 0.6, materials.gray());
            platformBase.position.y = -22;
            seatPlatform.add(platformBase);
            
            // プラットフォーム縁
            const platformEdge = helpers.createTorus(7, 0.25, 8, 32, Math.PI * 2, materials.darkGray());
            platformEdge.rotation.x = Math.PI / 2;
            platformEdge.position.y = -22;
            seatPlatform.add(platformEdge);
            
            // 座席（円形に配置、18席）
            for (let i = 0; i < 18; i++) {
                const angle = (i / 18) * Math.PI * 2;
                const seatGroup = new THREE.Group();
                
                // 座席本体
                const seat = helpers.createBox(1.3, 0.35, 1.1, materials.gray());
                seat.position.y = -21.6;
                
                // 背もたれ
                const backrest = helpers.createBox(1.3, 1.8, 0.2, materials.gray());
                backrest.position.set(0, -20.3, -0.45);
                
                // 安全ハーネス
                const harness = helpers.createBox(1.1, 0.12, 0.9, materials.black());
                harness.position.set(0, -20, 0);
                
                seatGroup.add(seat);
                seatGroup.add(backrest);
                seatGroup.add(harness);
                
                seatGroup.position.set(
                    Math.cos(angle) * 5.2,
                    0,
                    Math.sin(angle) * 5.2
                );
                seatGroup.rotation.y = angle;
                seatPlatform.add(seatGroup);
            }
            
            // 中央の装飾（回転軸）
            const centerHub = helpers.createCylinder(1.2, 1.2, 1.2, materials.black());
            centerHub.position.y = -22;
            seatPlatform.add(centerHub);
            
            pendulumArm.add(seatPlatform);
            pendulumArm.userData.seatPlatform = seatPlatform;
            
            pendulumArm.position.y = 24;
            pendulumArm.userData.swingAngle = 0;
            
            group.add(pendulumArm);
            group.userData.pendulumArm = pendulumArm;
            
            // 装飾ライト
            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * Math.PI * 2;
                const light = helpers.createSphere(0.22, 6, 6, materials.veryLightGray());
                light.position.set(
                    Math.cos(angle) * 9,
                    1.8,
                    Math.sin(angle) * 9
                );
                group.add(light);
            }
            
            group.position.set(0, 0, 50); // スタート地点の前に配置
            scene.add(group);
            animatedObjects.pendulumRide = group;
            
            group.updateMatrixWorld(true);
            buildings.push(group);
        }

        // 花壇
        function createFlowerBeds() {
            const flowerBedPositions = [
                [-15, 0, -15], [15, 0, -15],  // スタート地点近くの[15, 0, 15]と[-15, 0, 15]を削除
                [-30, 0, 0], [30, 0, 0], [0, 0, -30],  // [0, 0, 30]を削除（スタート地点近く）
                [-30, 0, -45], [-55, 0, 45], [45, 0, -45]  // 観覧車近くの花壇をさらに右に移動
            ];
            
            flowerBedPositions.forEach(pos => {
                const flowerBed = new THREE.Group();
                
                // 花壇の枠
                const border = helpers.createTorus(2, 0.3, 6, 16, Math.PI * 2, materials.mediumGray());
                border.rotation.x = Math.PI / 2;
                border.position.y = 0.15;
                flowerBed.add(border);
                
                // 花
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const radius = 0.5 + Math.random() * 1;
                    
                    const flower = new THREE.Group();
                    const stem = helpers.createCylinder(0.02, 0.02, 0.5 + Math.random() * 0.3, materials.darkGray());
                    stem.position.y = 0.25;
                    
                    const bloom = helpers.createSphere(0.15 + Math.random() * 0.1, 4, 4, materials.gray());
                    bloom.position.y = 0.5 + Math.random() * 0.3;
                    
                    flower.add(stem);
                    flower.add(bloom);
                    flower.position.set(
                        Math.cos(angle) * radius,
                        0,
                        Math.sin(angle) * radius
                    );
                    flower.rotation.y = Math.random() * Math.PI * 2;
                    
                    flowerBed.add(flower);
                }
                
                flowerBed.position.set(...pos);
                scene.add(flowerBed);
            });
        }

        // ゴミ箱
        function createTrashCans() {
            const trashCanPositions = [
                [-25, 0, -25], [25, 0, -25], [-25, 0, 25],  // [25, 0, 25]を削除
                [-50, 0, 0], [50, 0, 0], [0, 0, -50],  // [0, 0, 50]を削除
                [-35, 0, -50], [-50, 0, -35], [50, 0, 35],  // [35, 0, 50]を削除
                [-70, 0, -20], [70, 0, 20], [-20, 0, -70]  // [20, 0, 70]を削除
            ];
            
            trashCanPositions.forEach(pos => {
                const trashCan = new THREE.Group();
                
                const body = helpers.createCylinder(0.4, 0.5, 1, materials.mediumGray());
                body.position.y = 0.5;
                
                const rim = helpers.createTorus(0.5, 0.05, 8, 16, Math.PI * 2, materials.darkGray());
                rim.rotation.x = Math.PI / 2;
                rim.position.y = 1;
                
                const lid = helpers.createCylinder(0.5, 0.5, 0.1, materials.darkGray());
                lid.position.y = 1.05;
                
                trashCan.add(body);
                trashCan.add(rim);
                trashCan.add(lid);
                
                trashCan.position.set(...pos);
                scene.add(trashCan);
            });
        }

        // 案内看板
        function createSigns() {
            const signPositions = [
                // スタート地点近くの看板を削除
                { pos: [-60, 0, 30], text: "GAMES" },
                { pos: [60, 0, 30], text: "REST" }
            ];
            
            signPositions.forEach(sign => {
                const signGroup = new THREE.Group();
                
                const pole = helpers.createCylinder(0.1, 0.1, 3, materials.gray());
                pole.position.y = 1.5;
                
                const board = helpers.createBox(2, 1, 0.1, materials.darkGray());
                board.position.y = 3;
                
                // 矢印
                const arrow = new THREE.Group();
                const shaft = helpers.createBox(1, 0.1, 0.05, materials.lightGray());
                const head = new THREE.Mesh(
                    new THREE.ConeGeometry(0.2, 0.4, 3),
                    materials.lightGray()
                );
                head.rotation.z = -Math.PI / 2;
                head.position.x = 0.7;
                arrow.add(shaft);
                arrow.add(head);
                arrow.position.y = 3;
                arrow.position.z = 0.1;
                
                signGroup.add(pole);
                signGroup.add(board);
                signGroup.add(arrow);
                
                signGroup.position.set(...sign.pos);
                signGroup.rotation.y = Math.atan2(sign.pos[2], sign.pos[0]) + Math.PI;
                
                scene.add(signGroup);
            });
        }

        // フェンス（削除）
        function createFences() {
            // フェンスは削除されました
        }

        // ピクニックエリア
        function createPicnicAreas() {
            const picnicPositions = [
                [-70, 0, 40], [70, 0, -40]  // スタート地点近くの[-40, 0, 70]と[40, 0, -70]を削除
            ];
            
            picnicPositions.forEach(pos => {
                const picnicArea = new THREE.Group();
                
                // テーブル
                const tableTop = helpers.createCylinder(2, 2, 0.2, materials.darkGray());
                tableTop.position.y = 0.8;
                
                const tableLeg = helpers.createCylinder(0.3, 0.3, 0.8, materials.mediumGray());
                tableLeg.position.y = 0.4;
                
                // パラソル
                const parasol = new THREE.Group();
                const pole = helpers.createCylinder(0.1, 0.1, 2.5, materials.gray());
                pole.position.y = 1.25;
                
                const canopy = new THREE.Mesh(
                    new THREE.ConeGeometry(2.5, 1, 8),
                    materials.lightGray()
                );
                canopy.position.y = 2.5;
                
                parasol.add(pole);
                parasol.add(canopy);
                parasol.position.y = 0.9;
                
                picnicArea.add(tableTop);
                picnicArea.add(tableLeg);
                picnicArea.add(parasol);
                
                // 周りのベンチ
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const benchSeat = helpers.createBox(1.5, 0.15, 0.5, materials.lightGray());
                    benchSeat.position.set(
                        Math.cos(angle) * 2.5,
                        0.4,
                        Math.sin(angle) * 2.5
                    );
                    benchSeat.rotation.y = angle;
                    picnicArea.add(benchSeat);
                }
                
                picnicArea.position.set(...pos);
                scene.add(picnicArea);
            });
        };

        // 巨大な振り子時計塔
        function createGiantClockTower() {
            const group = new THREE.Group();
            
            // タワーの基礎部分（幅広で安定）
            const baseFoundation = helpers.createBox(20, 3, 20, materials.darkGray());
            baseFoundation.position.y = 1.5;
            group.add(baseFoundation);
            
            // 基礎の装飾（段階的な層）
            const base1 = helpers.createBox(18, 2, 18, materials.mediumGray());
            base1.position.y = 4;
            group.add(base1);
            
            const base2 = helpers.createBox(16, 1.5, 16, materials.gray());
            base2.position.y = 5.75;
            group.add(base2);
            
            // メインタワー構造（4本の柱）
            const pillarPositions = [
                [-5, 0, -5], [5, 0, -5], [-5, 0, 5], [5, 0, 5]
            ];
            
            pillarPositions.forEach(pos => {
                // 下部の太い柱
                const lowerPillar = helpers.createBox(2, 15, 2, materials.mediumGray());
                lowerPillar.position.set(pos[0], 14, pos[2]);
                group.add(lowerPillar);
                
                // 中部の柱
                const middlePillar = helpers.createBox(1.5, 15, 1.5, materials.gray());
                middlePillar.position.set(pos[0], 29, pos[2]);
                group.add(middlePillar);
                
                // 上部の細い柱
                const upperPillar = helpers.createBox(1, 8, 1, materials.lightGray());
                upperPillar.position.set(pos[0], 41, pos[2]);
                group.add(upperPillar);
            });
            
            // 水平ビーム（各階層）
            const beamLevels = [10, 20, 30, 35, 40];
            beamLevels.forEach(level => {
                // 前後のビーム
                const frontBeam = helpers.createCylinder(0.4, 0.4, 10, materials.darkGray());
                frontBeam.rotation.z = Math.PI / 2;
                frontBeam.position.set(0, level, -5);
                group.add(frontBeam);
                
                const backBeam = helpers.createCylinder(0.4, 0.4, 10, materials.darkGray());
                backBeam.rotation.z = Math.PI / 2;
                backBeam.position.set(0, level, 5);
                group.add(backBeam);
                
                // 左右のビーム
                const leftBeam = helpers.createCylinder(0.4, 0.4, 10, materials.darkGray());
                leftBeam.rotation.x = Math.PI / 2;
                leftBeam.position.set(-5, level, 0);
                group.add(leftBeam);
                
                const rightBeam = helpers.createCylinder(0.4, 0.4, 10, materials.darkGray());
                rightBeam.rotation.x = Math.PI / 2;
                rightBeam.position.set(5, level, 0);
                group.add(rightBeam);
                
                // 対角線ブレース
                if (level < 35) {
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        const brace = helpers.createCylinder(0.2, 0.2, 7, materials.lightGray());
                        brace.position.set(
                            Math.cos(angle) * 3.5,
                            level + 2.5,
                            Math.sin(angle) * 3.5
                        );
                        brace.lookAt(0, level + 7, 0);
                        group.add(brace);
                    }
                }
            });
            
            // 時計機構部分（25m〜35mの高さ）
            const clockMechanism = new THREE.Group();
            
            // 時計の文字盤（前面）
            const clockFace = new THREE.Group();
            
            // 文字盤の背景（明るい円盤を追加）
            const clockBackground = helpers.createCylinder(5.8, 5.8, 0.3, materials.veryLightGray());
            clockBackground.rotation.x = Math.PI / 2;
            clockBackground.position.z = -5.9;
            clockFace.add(clockBackground);
            
            // 文字盤の外枠
            const outerRim = helpers.createTorus(6, 0.3, 12, 48, Math.PI * 2, materials.black());
            outerRim.position.z = -6;
            clockFace.add(outerRim);
            
            const innerRim = helpers.createTorus(5.5, 0.2, 10, 36, Math.PI * 2, materials.darkGray());
            innerRim.position.z = -6;
            clockFace.add(innerRim);
            
            // 時計の数字（ローマ数字風のマーク）
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 - Math.PI / 2;
                const hourMark = helpers.createBox(0.3, 1, 0.1, materials.black());
                hourMark.position.set(
                    Math.cos(angle) * 5,
                    Math.sin(angle) * 5,
                    -6
                );
                hourMark.rotation.z = angle + Math.PI / 2;
                clockFace.add(hourMark);
                
                // 大きな数字（3, 6, 9, 12）には追加の装飾
                if (i % 3 === 0) {
                    const bigMark = helpers.createBox(0.5, 1.5, 0.1, materials.black());
                    bigMark.position.set(
                        Math.cos(angle) * 5,
                        Math.sin(angle) * 5,
                        -6.1
                    );
                    bigMark.rotation.z = angle + Math.PI / 2;
                    clockFace.add(bigMark);
                }
            }
            
            // 時計の針（より目立つ色と太さに変更）
            const hourHand = helpers.createBox(0.7, 3.5, 0.3, materials.black());
            hourHand.position.set(0, 1.75, -6.4);
            hourHand.userData.isHourHand = true;
            clockFace.add(hourHand);
            
            const minuteHand = helpers.createBox(0.5, 5, 0.3, materials.darkGray());
            minuteHand.position.set(0, 2.5, -6.5);
            minuteHand.userData.isMinuteHand = true;
            clockFace.add(minuteHand);
            
            // 中心のハブ（より大きく）
            const centerHub = helpers.createCylinder(0.7, 0.7, 0.6, materials.black());
            centerHub.rotation.x = Math.PI / 2;
            centerHub.position.z = -6.6;
            clockFace.add(centerHub);
            
            clockFace.position.y = 30;
            clockMechanism.add(clockFace);
            
            // 歯車システム（見える機械仕掛け）
            const gearSystem = new THREE.Group();
            
            // 大歯車
            const largeGear = new THREE.Group();
            const largeGearRim = helpers.createTorus(3, 0.3, 8, 32, Math.PI * 2, materials.mediumGray());
            const largeGearTeeth = [];
            for (let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2;
                const tooth = helpers.createBox(0.4, 0.8, 1, materials.gray());
                tooth.position.set(
                    Math.cos(angle) * 3.3,
                    Math.sin(angle) * 3.3,
                    0
                );
                tooth.rotation.z = angle;
                largeGearTeeth.push(tooth);
                largeGear.add(tooth);
            }
            largeGear.add(largeGearRim);
            
            // 歯車のスポーク
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const spoke = helpers.createCylinder(0.1, 0.1, 6, materials.lightGray());
                spoke.rotation.z = angle;
                largeGear.add(spoke);
            }
            
            largeGear.position.set(0, 30, 0);
            largeGear.userData.rotationSpeed = 0.001;
            gearSystem.add(largeGear);
            
            // 中歯車
            const mediumGear = new THREE.Group();
            const mediumGearRim = helpers.createTorus(2, 0.2, 6, 24, Math.PI * 2, materials.gray());
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const tooth = helpers.createBox(0.3, 0.6, 0.8, materials.lightGray());
                tooth.position.set(
                    Math.cos(angle) * 2.2,
                    Math.sin(angle) * 2.2,
                    0
                );
                tooth.rotation.z = angle;
                mediumGear.add(tooth);
            }
            mediumGear.add(mediumGearRim);
            mediumGear.position.set(4, 32, 0);
            mediumGear.userData.rotationSpeed = -0.0015;
            gearSystem.add(mediumGear);
            
            // 小歯車
            const smallGear = new THREE.Group();
            const smallGearRim = helpers.createTorus(1, 0.15, 6, 16, Math.PI * 2, materials.lightGray());
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const tooth = helpers.createBox(0.2, 0.4, 0.6, materials.veryLightGray());
                tooth.position.set(
                    Math.cos(angle) * 1.15,
                    Math.sin(angle) * 1.15,
                    0
                );
                tooth.rotation.z = angle;
                smallGear.add(tooth);
            }
            smallGear.add(smallGearRim);
            smallGear.position.set(-3, 28, 0);
            smallGear.userData.rotationSpeed = 0.003;
            gearSystem.add(smallGear);
            
            // 歯車を接続するシャフト
            const shaft1 = helpers.createCylinder(0.2, 0.2, 4, materials.darkGray());
            shaft1.position.set(2, 31, 0);
            gearSystem.add(shaft1);
            
            clockMechanism.add(gearSystem);
            clockMechanism.userData.gearSystem = gearSystem;
            
            // 振り子機構
            const pendulumSystem = new THREE.Group();
            
            // 振り子の支点
            const pivot = helpers.createCylinder(0.5, 0.5, 2, materials.darkGray());
            pivot.rotation.z = Math.PI / 2;
            pivot.position.set(0, 25, 0);
            pendulumSystem.add(pivot);
            
            // 振り子アーム
            const pendulumArm = new THREE.Group();
            
            // メインロッド
            const rod = helpers.createCylinder(0.3, 0.3, 20, materials.mediumGray());
            rod.position.y = -10;
            pendulumArm.add(rod);
            
            // 装飾的なブレース
            for (let i = 0; i < 3; i++) {
                const brace = helpers.createCylinder(0.1, 0.1, 1, materials.gray());
                brace.position.y = -3 - i * 5;
                brace.rotation.x = Math.PI / 4;
                pendulumArm.add(brace);
                
                const brace2 = helpers.createCylinder(0.1, 0.1, 1, materials.gray());
                brace2.position.y = -3 - i * 5;
                brace2.rotation.x = -Math.PI / 4;
                pendulumArm.add(brace2);
            }
            
            // 振り子の重り（装飾的な球体）
            const pendulumWeight = new THREE.Group();
            
            // メインウェイト
            const mainWeight = helpers.createSphere(2.5, 16, 16, materials.mediumGray());
            mainWeight.position.y = -20;
            pendulumWeight.add(mainWeight);
            
            // 装飾リング
            for (let i = 0; i < 3; i++) {
                const ring = helpers.createTorus(2.5 - i * 0.5, 0.1, 8, 24, Math.PI * 2, materials.gray());
                ring.position.y = -20 + (i - 1) * 1.5;
                pendulumWeight.add(ring);
            }
            
            // 底部の装飾
            const bottomCone = new THREE.Mesh(
                new THREE.ConeGeometry(1, 2, 8),
                materials.lightGray()
            );
            bottomCone.position.y = -23;
            pendulumWeight.add(bottomCone);
            
            pendulumArm.add(pendulumWeight);
            pendulumArm.position.y = 25;
            pendulumArm.userData.swingAngle = 0;
            pendulumSystem.add(pendulumArm);
            pendulumSystem.userData.pendulumArm = pendulumArm;
            
            clockMechanism.add(pendulumSystem);
            group.add(clockMechanism);
            group.userData.clockMechanism = clockMechanism;
            
            // タワートップ（45mの高さ）
            const towerTop = new THREE.Group();
            
            // 尖塔
            const spire = new THREE.Mesh(
                new THREE.ConeGeometry(3, 8, 8),
                materials.mediumGray()
            );
            spire.position.y = 47;
            towerTop.add(spire);
            
            // 装飾的な球体
            const topOrb = helpers.createSphere(1, 12, 12, materials.veryLightGray());
            topOrb.position.y = 51;
            towerTop.add(topOrb);
            
            // 避雷針
            const lightningRod = helpers.createCylinder(0.05, 0.05, 3, materials.darkGray());
            lightningRod.position.y = 52.5;
            towerTop.add(lightningRod);
            
            group.add(towerTop);
            
            // ベル（チャイム用）
            const bellSystem = new THREE.Group();
            
            // 大きなベル
            const largeBell = new THREE.Group();
            const bellShape = new THREE.Mesh(
                new THREE.SphereGeometry(1.5, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2),
                materials.mediumGray()
            );
            bellShape.position.y = 38;
            largeBell.add(bellShape);
            
            const bellRim = helpers.createTorus(1.5, 0.1, 8, 16, Math.PI * 2, materials.darkGray());
            bellRim.rotation.x = Math.PI / 2;
            bellRim.position.y = 38;
            largeBell.add(bellRim);
            
            // ベルのクラッパー（振り子）
            const clapper = helpers.createCylinder(0.1, 0.1, 1.5, materials.darkGray());
            clapper.position.y = 37.5;
            largeBell.add(clapper);
            
            const clapperBall = helpers.createSphere(0.3, 6, 6, materials.black());
            clapperBall.position.y = 36.75;
            largeBell.add(clapperBall);
            
            largeBell.userData.isChimeBell = true;
            bellSystem.add(largeBell);
            
            // 小さなベル（装飾）
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const smallBell = bellShape.clone();
                smallBell.scale.set(0.5, 0.5, 0.5);
                smallBell.position.set(
                    Math.cos(angle) * 4,
                    36,
                    Math.sin(angle) * 4
                );
                bellSystem.add(smallBell);
            }
            
            bellSystem.userData.lastChimeTime = 0;
            group.add(bellSystem);
            group.userData.bellSystem = bellSystem;
            
            // 装飾的なアーチ（各面）
            const archHeight = 15;
            const archPositions = [
                { pos: [0, archHeight, -7], rot: 0 },
                { pos: [0, archHeight, 7], rot: Math.PI },
                { pos: [-7, archHeight, 0], rot: Math.PI / 2 },
                { pos: [7, archHeight, 0], rot: -Math.PI / 2 }
            ];
            
            archPositions.forEach(arch => {
                const archGroup = new THREE.Group();
                
                // アーチの曲線
                const archCurve = helpers.createTorus(4, 0.3, 8, 16, Math.PI, materials.mediumGray());
                archCurve.rotation.z = Math.PI;
                archGroup.add(archCurve);
                
                // アーチの装飾
                for (let i = 0; i <= 5; i++) {
                    const angle = (i / 5) * Math.PI;
                    const decoration = helpers.createSphere(0.2, 6, 6, materials.lightGray());
                    decoration.position.set(
                        Math.cos(angle) * 4,
                        Math.sin(angle) * 4,
                        0
                    );
                    archGroup.add(decoration);
                }
                
                archGroup.position.set(...arch.pos);
                archGroup.rotation.y = arch.rot;
                group.add(archGroup);
            });
            
            // 奥の空いているスペースに配置
            group.position.set(0, 0, -60);
            group.rotation.y = Math.PI;  // 180度回転
            scene.add(group);
            animatedObjects.clockTower = group;
            
            group.updateMatrixWorld(true);
            buildings.push(group);
        }

        // ポインターロックなしで開始
        function startWithoutPointerLock() {
            usePointerLock = false;
            isLocked = true;
            document.getElementById('lockPrompt').style.display = 'none';
            
            // マウス位置を初期化
            const rect = renderer.domElement.getBoundingClientRect();
            prevMouseX = rect.width / 2;
            prevMouseY = rect.height / 2;
            totalYawRotation = 0;
            totalPitchRotation = 0;
            lastMouseEvent = null;
            
            document.addEventListener('mousemove', onMouseMoveAlternative);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            
            // タイマーを開始
            startTimer();
        }

        // 代替マウス移動処理
        function onMouseMoveAlternative(event) {
            if (!isLocked) return;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const currentMouseX = event.clientX - rect.left;
            const currentMouseY = event.clientY - rect.top;
            
            // 前回のイベントがある場合のみ処理
            if (lastMouseEvent) {
                const deltaX = currentMouseX - prevMouseX;
                const deltaY = currentMouseY - prevMouseY;
                
                // 画面端でのジャンプを検出して無視
                const maxDelta = Math.min(rect.width, rect.height) / 4;
                if (Math.abs(deltaX) < maxDelta && Math.abs(deltaY) < maxDelta) {
                    // 累積回転角度を更新（左右は無制限）
                    totalYawRotation -= deltaX * 0.01;
                    totalPitchRotation += deltaY * 0.005;
                    
                    // ピッチ（上下）は制限
                    totalPitchRotation = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, totalPitchRotation));
                    
                    // 回転を適用
                    yawObject.rotation.y = totalYawRotation;
                    pitchObject.rotation.x = totalPitchRotation;
                }
            }
            
            // 前回のマウス位置を保存
            prevMouseX = currentMouseX;
            prevMouseY = currentMouseY;
            lastMouseEvent = event;
            
            // マウスが画面端に近づいたら中央付近にリセット
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const edgeThreshold = 50; // 画面端から50px以内
            
            if (currentMouseX < edgeThreshold || currentMouseX > rect.width - edgeThreshold ||
                currentMouseY < edgeThreshold || currentMouseY > rect.height - edgeThreshold) {
                
                // 仮想的に中央にリセット（実際のカーソルは動かせないので内部状態のみ）
                prevMouseX = centerX;
                prevMouseY = centerY;
            }
        }

        // 初期化
        function init() {
            // シーン作成
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            scene.fog = new THREE.Fog(0xffffff, 80, 300);  // フォグの範囲を250から300に拡張

            // カメラ設定
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // カメラコントロール用のオブジェクト
            pitchObject = new THREE.Object3D();
            pitchObject.add(camera);
            
            yawObject = new THREE.Object3D();
            yawObject.position.y = 1.6; // 人間の目の高さ（約1.6m）に設定
            yawObject.position.z = 85; // 入口近くに配置
            yawObject.add(pitchObject);
            scene.add(yawObject);

            // レンダラー設定
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('gameCanvas'), 
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // ライト設定
            const ambientLight = new THREE.AmbientLight(0x808080, 0.8);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);

            // 遊園地を作成
            createAmusementPark();

            // イベントリスナー
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);

            // スタートボタンのイベントリスナー
            document.getElementById('startButton').addEventListener('click', startWithoutPointerLock);

            // ポインターロック設定
            const lockPrompt = document.getElementById('lockPrompt');
            
            document.addEventListener('click', (event) => {
                if (!isLocked && event.target.tagName !== 'BUTTON') {
                    const element = document.body;
                    element.requestPointerLock = element.requestPointerLock ||
                                                element.mozRequestPointerLock ||
                                                element.webkitRequestPointerLock;
                    
                    if (element.requestPointerLock) {
                        element.requestPointerLock();
                    }
                } else if (isLocked) {
                    shoot();
                }
            });

            // ポインターロックのイベントリスナー
            const pointerLockChange = () => {
                if (document.pointerLockElement === document.body ||
                    document.mozPointerLockElement === document.body ||
                    document.webkitPointerLockElement === document.body) {
                    isLocked = true;
                    lockPrompt.style.display = 'none';
                    document.addEventListener('mousemove', onMouseMove);
                    // タイマーを開始
                    startTimer();
                } else {
                    isLocked = false;
                    lockPrompt.style.display = 'block';
                    document.removeEventListener('mousemove', onMouseMove);
                }
            };

            document.addEventListener('pointerlockchange', pointerLockChange);
            document.addEventListener('mozpointerlockchange', pointerLockChange);
            document.addEventListener('webkitpointerlockchange', pointerLockChange);

            

            // ESCキーでも閉じる
            document.addEventListener('keydown', function (event) {
                if (event.key === 'Escape') {
                    closeGame();
                }
            });
        }

        // 遊園地作成
        function createAmusementPark() {
            // 地面
            createGround();
            
            // すべてのアトラクション
            createFerrisWheel();
            createMerryGoRound();
            createRollerCoaster();
            createSwingRide();
            createFreeFall();
            createVikingShip();
            createTeacups();
            createGoKarts();
            createMiniTrain();
            
            // 新しいアトラクション
            createPendulumRide();
            
            // 巨大な振り子時計塔
            createGiantClockTower();
            
            // 装飾
            createTrees();
            createBenches();
            createLamps();
            createFlowerBeds();
            createTrashCans();
            createSigns();
            createFences();
            createPicnicAreas();
            
            // 月と星座
            createMoon();
            createConstellations();
            createStars();
            
            // すべての建物が配置された後にターゲットを作成
            createTargets();
        }

        // 親へ「閉じる」通知（マンガへ戻る）
        function closeGame() {
            try { if (document.exitPointerLock) document.exitPointerLock(); } catch (e) {}
            try { if (window.parent) window.parent.postMessage({ type: 'CLOSE_MINI_GAME' }, '*'); } catch (e) {}
        }

        // 地面作成
        function createGround() {
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200),
                new THREE.MeshBasicMaterial({ color: 0xf5f5f5, transparent: true, opacity: 0.3 })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            scene.add(ground);

            const gridHelper = new THREE.GridHelper(200, 40, 0x999999, 0xdddddd);
            scene.add(gridHelper);

            // 地面のパターン
            const patternMaterial = materials.line(0xaaaaaa);
            
            // 放射状のパターン
            for (let i = 0; i < 8; i++) {  // 16から8に減らす
                const angle = (i / 8) * Math.PI * 2;  // 8で割る
                const line = helpers.createLine([
                    new THREE.Vector3(0, 0.05, 0),
                    new THREE.Vector3(Math.cos(angle) * 100, 0.05, Math.sin(angle) * 100)
                ], patternMaterial);
                scene.add(line);
            }

            // 遊園地らしい装飾的な床パターン
            // カラフルなタイルエリア（アトラクション周り）
            const attractionAreas = [
                { center: [-50, 0, -50], radius: 20 }, // 観覧車
                { center: [50, 0, 50], radius: 18 },   // メリーゴーランド
                { center: [60, 0, -60], radius: 20 },  // スイングライド
                { center: [-60, 0, 0], radius: 15 },   // フリーフォール
                { center: [60, 0, 0], radius: 25 },    // バイキングシップ
                { center: [-30, 0, 30], radius: 12 },  // ティーカップ
                { center: [0, 0, 50], radius: 15 },    // ペンデュラムライド
                { center: [0, 0, -60], radius: 18 }    // 時計塔
            ];

            attractionAreas.forEach((area, index) => {
                // 装飾的な円形パターン
                for (let r = 5; r <= area.radius; r += 5) {
                    const circleGeometry = new THREE.RingGeometry(r - 0.3, r, 32);
                    const circleMaterial = new THREE.MeshBasicMaterial({
                        color: index % 2 === 0 ? 0x888888 : 0x777777,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.2
                    });
                    const circle = new THREE.Mesh(circleGeometry, circleMaterial);
                    circle.rotation.x = -Math.PI / 2;
                    circle.position.set(area.center[0], 0.01, area.center[2]);
                    scene.add(circle);
                }

                // 放射状の装飾線
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const decorLine = helpers.createLine([
                        new THREE.Vector3(
                            area.center[0] + Math.cos(angle) * 3,
                            0.02,
                            area.center[2] + Math.sin(angle) * 3
                        ),
                        new THREE.Vector3(
                            area.center[0] + Math.cos(angle) * area.radius,
                            0.02,
                            area.center[2] + Math.sin(angle) * area.radius
                        )
                    ], materials.line(0x999999, 0.3));
                    scene.add(decorLine);
                }
            });

            // 歩道パターン（曲線的な道）
            const pathCurves = [
                // メインの環状道路
                new THREE.EllipseCurve(0, 0, 50, 50, 0, 2 * Math.PI, false, 0),
                new THREE.EllipseCurve(0, 0, 75, 75, 0, 2 * Math.PI, false, 0),
                
                // アトラクション間を結ぶ道
                new THREE.CubicBezierCurve3(
                    new THREE.Vector3(-50, 0.02, -50),
                    new THREE.Vector3(-25, 0.02, -25),
                    new THREE.Vector3(-25, 0.02, 25),
                    new THREE.Vector3(-30, 0.02, 30)
                ),
                new THREE.CubicBezierCurve3(
                    new THREE.Vector3(50, 0.02, 50),
                    new THREE.Vector3(25, 0.02, 25),
                    new THREE.Vector3(25, 0.02, -25),
                    new THREE.Vector3(60, 0.02, -60)
                ),
                new THREE.CubicBezierCurve3(
                    new THREE.Vector3(-60, 0.02, 0),
                    new THREE.Vector3(-30, 0.02, 0),
                    new THREE.Vector3(30, 0.02, 0),
                    new THREE.Vector3(60, 0.02, 0)
                )
            ];

            // 歩道の描画
            pathCurves.forEach((curve, index) => {
                let points;
                if (curve instanceof THREE.EllipseCurve) {
                    const curve2D = curve.getPoints(64);
                    points = curve2D.map(p => new THREE.Vector3(p.x, 0.02, p.y));
                } else {
                    points = curve.getPoints(50);
                }
                
                // メインの道
                const pathLine = helpers.createLine(points, materials.line(0x666666, 0.4));
                scene.add(pathLine);
                
                // 道の両側のライン
                const offsetPoints1 = points.map(p => {
                    const offset = new THREE.Vector3(p.x, p.y, p.z);
                    const dir = new THREE.Vector2(p.x, p.z).normalize();
                    offset.x += dir.y * 2;
                    offset.z -= dir.x * 2;
                    return offset;
                });
                const offsetPoints2 = points.map(p => {
                    const offset = new THREE.Vector3(p.x, p.y, p.z);
                    const dir = new THREE.Vector2(p.x, p.z).normalize();
                    offset.x -= dir.y * 2;
                    offset.z += dir.x * 2;
                    return offset;
                });
                
                if (index < 2) { // 環状道路のみに側線を追加
                    const sideLine1 = helpers.createLine(offsetPoints1, materials.line(0x888888, 0.2));
                    const sideLine2 = helpers.createLine(offsetPoints2, materials.line(0x888888, 0.2));
                    scene.add(sideLine1);
                    scene.add(sideLine2);
                }
            });

            // 装飾的なタイルパターン（入口エリア）
            const entranceArea = new THREE.Group();
            for (let x = -15; x <= 15; x += 5) {
                for (let z = 70; z <= 90; z += 5) {
                    const tile = new THREE.Mesh(
                        new THREE.PlaneGeometry(4.8, 4.8),
                        new THREE.MeshBasicMaterial({
                            color: (x + z) % 10 === 0 ? 0x777777 : 0x999999,
                            transparent: true,
                            opacity: 0.15,
                            side: THREE.DoubleSide
                        })
                    );
                    tile.rotation.x = -Math.PI / 2;
                    tile.position.set(x, 0.01, z);
                    entranceArea.add(tile);
                    
                    // タイルの境界線
                    const tileBorder = new THREE.LineLoop(
                        new THREE.BufferGeometry().setFromPoints([
                            new THREE.Vector3(x - 2.4, 0.02, z - 2.4),
                            new THREE.Vector3(x + 2.4, 0.02, z - 2.4),
                            new THREE.Vector3(x + 2.4, 0.02, z + 2.4),
                            new THREE.Vector3(x - 2.4, 0.02, z + 2.4)
                        ]),
                        materials.line(0x888888, 0.3)
                    );
                    entranceArea.add(tileBorder);
                }
            }
            scene.add(entranceArea);

            // 星形の装飾パターン（各所に配置）
            const starPositions = [
                [0, 0], [-35, 35], [35, -35], [-70, -70], [70, 70]
            ];
            
            starPositions.forEach(pos => {
                const starGroup = new THREE.Group();
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const innerRadius = 3;
                    const outerRadius = 6;
                    
                    const points = [];
                    for (let j = 0; j < 16; j++) {
                        const a = (j / 16) * Math.PI * 2;
                        const r = j % 2 === 0 ? outerRadius : innerRadius;
                        points.push(new THREE.Vector3(
                            Math.cos(a) * r,
                            0.02,
                            Math.sin(a) * r
                        ));
                    }
                    points.push(points[0]); // 閉じる
                    
                    const star = helpers.createLine(points, materials.line(0x777777, 0.2));
                    star.position.set(pos[0], 0, pos[1]);
                    starGroup.add(star);
                }
                scene.add(starGroup);
            });

            // プラザ（広場）の改良
            const plazaPositions = [
                { x: -30, z: -30, r: 10 },
                { x: 30, z: -30, r: 10 }
            ];

            plazaPositions.forEach(plaza => {
                const plazaGroup = new THREE.Group();
                
                // 装飾的な床パターン
                for (let ring = 0; ring < 3; ring++) {
                    const radius = plaza.r - ring * 3;
                    if (radius > 0) {
                        const plazaRing = new THREE.Mesh(
                            new THREE.RingGeometry(radius - 0.5, radius, 32),
                            new THREE.MeshBasicMaterial({ 
                                color: ring % 2 === 0 ? 0x666666 : 0x888888, 
                                side: THREE.DoubleSide,
                                transparent: true,
                                opacity: 0.2
                            })
                        );
                        plazaRing.rotation.x = -Math.PI / 2;
                        plazaRing.position.y = 0.02;
                        plazaGroup.add(plazaRing);
                    }
                }
                
                // プラザの装飾線
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const decorLine = helpers.createLine([
                        new THREE.Vector3(
                            Math.cos(angle) * 2,
                            0.02,
                            Math.sin(angle) * 2
                        ),
                        new THREE.Vector3(
                            Math.cos(angle) * plaza.r,
                            0.02,
                            Math.sin(angle) * plaza.r
                        )
                    ], materials.line(0x999999, 0.2));
                    plazaGroup.add(decorLine);
                }

                plazaGroup.position.set(plaza.x, 0, plaza.z);
                scene.add(plazaGroup);
            });
        }

        // 観覧車（シンプルな八の字型デザイン）
        function createFerrisWheel() {
            const group = new THREE.Group();
            const wheelRadius = 15;
            
            // シンプルな八の字型支柱（左）- 距離を広げる
            const leftSupport = helpers.createCylinder(1.2, 3.5, 30, materials.mediumGray());
            leftSupport.position.set(-4, 15, 0);  // -2から-4に変更（距離を広げる）
            leftSupport.rotation.z = -0.15;  // 傾きを少し緩やかに
            group.add(leftSupport);
            
            // シンプルな八の字型支柱（右）- 距離を広げる
            const rightSupport = helpers.createCylinder(1.2, 3.5, 30, materials.mediumGray());
            rightSupport.position.set(4, 15, 0);  // 2から4に変更（距離を広げる）
            rightSupport.rotation.z = 0.15;  // 傾きを少し緩やかに
            group.add(rightSupport);
            
            // 支柱間の横梁（上部）- 長さを調整
            const topBrace = helpers.createCylinder(0.5, 0.5, 8, materials.darkGray());
            topBrace.rotation.z = Math.PI / 2;
            topBrace.position.y = 27;
            group.add(topBrace);
            
            // 基礎（より広く安定）
            const foundation = helpers.createCylinder(12, 14, 2, materials.darkGray());
            foundation.position.y = 1;
            group.add(foundation);
            
            // 回転軸
            const axle = helpers.createCylinder(0.8, 0.8, 10, materials.black());
            axle.rotation.z = Math.PI / 2;
            axle.position.y = 22;
            group.add(axle);
            
            // 回転する部分のグループ
            const wheelGroup = new THREE.Group();
            
            // メインホイール（シンプルな構成）
            const outerRing = helpers.createTorus(wheelRadius, 0.3, 12, 64, Math.PI * 2, materials.black());
            const middleRing = helpers.createTorus(wheelRadius - 1.5, 0.2, 10, 48, Math.PI * 2, materials.darkGray());
            const innerRing = helpers.createTorus(wheelRadius - 3, 0.15, 8, 32, Math.PI * 2, materials.mediumGray());
            wheelGroup.add(outerRing);
            wheelGroup.add(middleRing);
            wheelGroup.add(innerRing);

            // スポーク（12本）
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const spoke = helpers.createCylinder(0.08, 0.08, wheelRadius * 2, materials.black());
                spoke.rotation.z = angle;
                wheelGroup.add(spoke);
            }

            // 中央ハブ
            const centralHub = helpers.createCylinder(1.5, 1.5, 1, materials.black());
            wheelGroup.add(centralHub);

            // ゴンドラ（12個）
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const gondolaGroup = new THREE.Group();
                
                // シンプルなゴンドラ
                const gondola = helpers.createBox(2.1, 2.1, 2.1, materials.darkGray());
                
                // 窓（4面）
                for (let j = 0; j < 4; j++) {
                    const windowAngle = (j / 4) * Math.PI * 2;
                    const window = helpers.createBox(0.05, 1.4, 1.4, materials.transparent(0x666666, 0.5));
                    window.position.set(
                        Math.cos(windowAngle) * 1.1,
                        0,
                        Math.sin(windowAngle) * 1.1
                    );
                    if (j % 2 === 0) window.rotation.y = Math.PI / 2;
                    gondolaGroup.add(window);
                }
                
                // 屋根
                const roof = helpers.createBox(2.3, 0.1, 2.3, materials.gray());
                roof.position.y = 1.1;
                gondolaGroup.add(roof);
                
                // サスペンション（シンプルな2本）
                const suspension1 = helpers.createCylinder(0.05, 0.05, 1.5, materials.lightGray());
                suspension1.position.set(0.75, 0.8, 0);
                const suspension2 = helpers.createCylinder(0.05, 0.05, 1.5, materials.lightGray());
                suspension2.position.set(-0.75, 0.8, 0);
                
                gondolaGroup.add(gondola);
                gondolaGroup.add(suspension1);
                gondolaGroup.add(suspension2);
                
                gondolaGroup.position.set(
                    Math.cos(angle) * wheelRadius,
                    Math.sin(angle) * wheelRadius,
                    0
                );
                gondolaGroup.userData.rotation = angle;
                wheelGroup.add(gondolaGroup);
            }
            
            wheelGroup.position.y = 22;
            group.add(wheelGroup);
            group.userData.wheelGroup = wheelGroup;
            
            // 装飾ライト（12個）
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const light = helpers.createSphere(0.15, 6, 6, materials.veryLightGray());
                light.position.set(
                    Math.cos(angle) * (wheelRadius + 1),
                    Math.sin(angle) * (wheelRadius + 1) + 22,
                    0
                );
                group.add(light);
            }

            group.position.set(-50, 0, -50);
            scene.add(group);
            animatedObjects.ferrisWheel = group;
            
            group.updateMatrixWorld(true);
            buildings.push(group);
        }

        // メリーゴーランド（高品質バランス版）
        function createMerryGoRound() {
            const group = new THREE.Group();
            
            // シンプルなプラットフォーム（大きくした）
            const mainPlatform = helpers.createCylinder(14, 14, 0.8, materials.gray());
            mainPlatform.position.y = 0.4;
            group.add(mainPlatform);

            // 装飾的なエッジ（1つのみ）
            const outerEdgeRing = helpers.createTorus(14.5, 0.2, 8, 32, Math.PI * 2, materials.lightGray());
            outerEdgeRing.rotation.x = Math.PI / 2;
            outerEdgeRing.position.y = 0.4;
            group.add(outerEdgeRing);
            
            // プラットフォームの放射状パターン（4本に削減）
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const spoke = helpers.createBox(0.12, 0.15, 14, materials.gray());
                spoke.position.y = 0.9;
                spoke.rotation.y = angle;
                group.add(spoke);
            }

            // 中央のポール構造（よりシンプル）
            const mainPole = helpers.createCylinder(1, 1, 18, materials.black());
            mainPole.position.y = 9;
            group.add(mainPole);

            // メインキャノピー（シンプルな円錐）
            const mainCanopy = new THREE.Mesh(
                new THREE.ConeGeometry(15, 8, 8),
                materials.darkGray()
            );
            mainCanopy.position.y = 21;
            group.add(mainCanopy);
            
            // トップ構造（シンプル）
            const topOrnament = helpers.createSphere(0.7, 8, 8, materials.lightGray());
            topOrnament.position.y = 28;
            group.add(topOrnament);

            // シンプルな馬（10頭に増やす）
            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * Math.PI * 2;
                const horseGroup = new THREE.Group();
                
                // 馬の体（少し大きく）
                const horseBody = helpers.createBox(2.2, 3, 4.2, materials.gray());
                horseBody.position.y = 0.6;
                
                // 馬の首
                const horseNeck = helpers.createBox(1.1, 2.5, 1.5, materials.gray());
                horseNeck.position.set(0, 2.8, 2.5);
                horseNeck.rotation.x = -0.35;
                
                // 馬の頭
                const horseHead = helpers.createBox(1, 1.6, 2.5, materials.gray());
                horseHead.position.set(0, 4.3, 3.7);
                
                // 脚（4本、シンプル化）
                const legPositions = [
                    [0.9, -1, 1.6], [-0.9, -1, 1.6],
                    [0.9, -1, -1.2], [-0.9, -1, -1.2]
                ];
                legPositions.forEach((pos, index) => {
                    const leg = helpers.createCylinder(0.25, 0.2, 2, materials.mediumGray());
                    leg.position.set(...pos);
                    horseGroup.add(leg);
                });
                
                // サドル（シンプル）
                const saddleBase = helpers.createBox(1.6, 0.5, 2.5, materials.lightGray());
                saddleBase.position.set(0, 2.3, 0);
                
                // 手綱用ポール（シンプル）
                const mainPole = helpers.createCylinder(0.15, 0.15, 12, materials.gold());
                mainPole.position.y = 6;
                
                // ポール装飾（1つのみ）
                const decorRing = helpers.createTorus(0.35, 0.09, 8, 16, Math.PI * 2, materials.veryLightGray());
                decorRing.rotation.x = Math.PI / 2;
                decorRing.position.y = 6.7;
                horseGroup.add(decorRing);
                
                // ポールトップ
                const poleTop = helpers.createSphere(0.35, 8, 8, materials.gold());
                poleTop.position.y = 12.5;
                
                horseGroup.add(horseBody);
                horseGroup.add(horseNeck);
                horseGroup.add(horseHead);
                horseGroup.add(saddleBase);
                horseGroup.add(mainPole);
                horseGroup.add(poleTop);
                
                horseGroup.position.set(
                    Math.cos(angle) * 10.5,
                    2.3,
                    Math.sin(angle) * 10.5
                );
                horseGroup.rotation.y = angle + Math.PI / 2;
                horseGroup.userData.angle = angle;
                horseGroup.userData.baseY = 2.3;
                group.add(horseGroup);
            }
            
            // 内側の装飾構造（3本に増やす）
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                
                // 装飾ポール
                const decorPole = helpers.createCylinder(0.2, 0.2, 18, materials.mediumGray());
                decorPole.position.set(
                    Math.cos(angle) * 5.5,
                    6,
                    Math.sin(angle) * 5.5
                );
                
                group.add(decorPole);
            }
            
            // キャノピー下の装飾ライト（6個に増やす）
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const light = helpers.createSphere(0.25, 8, 8, materials.veryLightGray());
                light.position.set(
                    Math.cos(angle) * 14,
                    17,
                    Math.sin(angle) * 14
                );
                group.add(light);
            }

            // メリーゴーランドを右手前に配置（少し中央寄りに）
            group.position.x = 50;
            group.position.y = 0;
            group.position.z = 50;
            scene.add(group);
            animatedObjects.merryGoRound = group;
            
            group.updateMatrixWorld(true);
            buildings.push(group);
        }

        // スイングライド（大幅に改良）
        function createSwingRide() {
            const group = new THREE.Group();
            
            // 強化された基盤構造
            const foundation = helpers.createCylinder(6, 6, 2, materials.darkGray());
            foundation.position.y = 1;
            group.add(foundation);
            
            // 基盤の装飾リング
            for (let i = 0; i < 3; i++) {
                const ring = helpers.createTorus(6 + i * 0.7, 0.15, 8, 24, Math.PI * 2, materials.mediumGray());
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 0.7 + i * 0.4;
                group.add(ring);
            }
            
            // メインタワー構造（8本の支柱で構成）
            const towerHeight = 30;
            const towerRadius = 3.5;
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const pillar = helpers.createCylinder(0.2, 0.25, towerHeight, materials.mediumGray());
                pillar.position.set(
                    Math.cos(angle) * towerRadius,
                    towerHeight / 2,
                    Math.sin(angle) * towerRadius
                );
                group.add(pillar);
                
                // 斜めのサポートビーム
                if (i % 2 === 0) {
                    const supportBeam = helpers.createCylinder(0.15, 0.15, towerHeight * 0.6, materials.lightGray());
                    supportBeam.position.set(
                        Math.cos(angle) * (towerRadius + 2),
                        towerHeight * 0.25,
                        Math.sin(angle) * (towerRadius + 2)
                    );
                    supportBeam.rotation.z = -0.3;
                    supportBeam.lookAt(0, towerHeight * 0.7, 0);
                    group.add(supportBeam);
                }
            }
            
            // 水平クロスブレース（X型構造）
            for (let h = 6; h < towerHeight; h += 6) {
                for (let i = 0; i < 4; i++) {
                    const angle1 = (i / 4) * Math.PI * 2;
                    const angle2 = ((i + 1) / 4) * Math.PI * 2;
                    
                    const points = [
                        new THREE.Vector3(
                            Math.cos(angle1) * towerRadius,
                            h,
                            Math.sin(angle1) * towerRadius
                        ),
                        new THREE.Vector3(
                            Math.cos(angle2) * towerRadius,
                            h + 3,
                            Math.sin(angle2) * towerRadius
                        )
                    ];
                    const crossBrace = helpers.createLine(points, materials.gray());
                    group.add(crossBrace);
                }
            }

            // 上部回転機構（より詳細）
            const rotatingHub = new THREE.Group();
            
            // ハブの多層構造
            const hubBase = helpers.createCylinder(4, 4, 1.5, materials.black());
            hubBase.position.y = 27;
            rotatingHub.add(hubBase);
            
            const hubMiddle = helpers.createCylinder(3.5, 3.5, 1.2, materials.darkGray());
            hubMiddle.position.y = 28.3;
            rotatingHub.add(hubMiddle);
            
            const hubTop = helpers.createCylinder(3, 3, 0.8, materials.black());
            hubTop.position.y = 29.4;
            rotatingHub.add(hubTop);

            // 回転ディスク（多層構造）
            const discGroup = new THREE.Group();
            
            // メインディスク
            const mainDisc = helpers.createCylinder(15, 15, 1.2, materials.darkGray());
            mainDisc.position.y = 30;
            discGroup.add(mainDisc);
            
            // ディスクの補強リブ（放射状）
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const rib = helpers.createBox(0.15, 0.7, 15, materials.mediumGray());
                rib.position.set(
                    Math.cos(angle) * 7.5,
                    30,
                    Math.sin(angle) * 7.5
                );
                rib.rotation.y = angle;
                discGroup.add(rib);
            }
            
            // ディスクエッジの装飾
            const outerRing = helpers.createTorus(15, 0.3, 12, 48, Math.PI * 2, materials.black());
            outerRing.rotation.x = Math.PI / 2;
            outerRing.position.y = 30;
            discGroup.add(outerRing);
            
            const innerRing = helpers.createTorus(12, 0.2, 10, 36, Math.PI * 2, materials.mediumGray());
            innerRing.rotation.x = Math.PI / 2;
            innerRing.position.y = 30;
            discGroup.add(innerRing);
            
            rotatingHub.add(discGroup);
            group.add(rotatingHub);

            // 高品質スイング（16個）
            const swingContainer = new THREE.Group();
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const swingGroup = new THREE.Group();
                
                // チェーンアタッチメント
                const attachment = helpers.createBox(0.5, 0.3, 0.8, materials.black());
                attachment.position.y = -0.15;
                
                // 改良されたチェーン（より細かいリンク）
                const chainGroup = new THREE.Group();
                const chainLength = 20;
                const linkHeight = 0.4;
                const linkCount = Math.floor(chainLength / linkHeight);
                
                for (let j = 0; j < linkCount; j++) {
                    // チェーンリンク（交互の向き）
                    const link = helpers.createTorus(0.15, 0.025, 4, 8, Math.PI * 2, materials.mediumGray());
                    link.position.y = -j * linkHeight;
                    if (j % 2 === 0) {
                        link.rotation.x = Math.PI / 2;
                    } else {
                        link.rotation.z = Math.PI / 2;
                    }
                    chainGroup.add(link);
                }
                
                // スイングシート（より詳細）
                const seatGroup = new THREE.Group();
                seatGroup.position.y = -chainLength;
                
                // シートフレーム
                const seatFrame = helpers.createBox(1.8, 0.1, 1.5, materials.darkGray());
                
                // シート表面（格子状）
                for (let sx = -0.8; sx <= 0.8; sx += 0.4) {
                    const seatBar = helpers.createCylinder(0.03, 0.03, 1.5, materials.gray());
                    seatBar.rotation.x = Math.PI / 2;
                    seatBar.position.set(sx, 0.07, 0);
                    seatGroup.add(seatBar);
                }
                for (let sz = -0.6; sz <= 0.6; sz += 0.3) {
                    const seatBar = helpers.createCylinder(0.03, 0.03, 1.8, materials.gray());
                    seatBar.rotation.z = Math.PI / 2;
                    seatBar.position.set(0, 0.07, sz);
                    seatGroup.add(seatBar);
                }
                
                // シートの背もたれ
                const backrest = helpers.createBox(1.5, 2.4, 0.15, materials.gray());
                backrest.position.set(0, 1.2, -0.7);
                seatGroup.add(backrest);
                
                // 背もたれの格子
                for (let by = 0.3; by <= 2.1; by += 0.6) {
                    const backBar = helpers.createCylinder(0.03, 0.03, 1.5, materials.lightGray());
                    backBar.rotation.z = Math.PI / 2;
                    backBar.position.set(0, by, -0.75);
                    seatGroup.add(backBar);
                }
                
                // アームレスト
                const leftArm = helpers.createBox(0.15, 0.8, 1, materials.mediumGray());
                leftArm.position.set(-0.85, 0.5, 0);
                const rightArm = helpers.createBox(0.15, 0.8, 1, materials.mediumGray());
                rightArm.position.set(0.85, 0.5, 0);
                
                // 安全バー
                const safetyBar = helpers.createTorus(0.8, 0.04, 6, 12, Math.PI, materials.black());
                safetyBar.rotation.x = Math.PI / 2;
                safetyBar.position.set(0, 0.9, 0.4);
                
                seatGroup.add(seatFrame);
                seatGroup.add(backrest);
                seatGroup.add(leftArm);
                seatGroup.add(rightArm);
                seatGroup.add(safetyBar);
                
                chainGroup.add(seatGroup);
                chainGroup.add(attachment);
                
                // スイング全体の位置をディスクの端に配置
                swingGroup.position.set(
                    Math.cos(angle) * 14.5,
                    29.7,
                    Math.sin(angle) * 14.5
                );
                
                swingGroup.add(chainGroup);
                swingGroup.userData.angle = angle;
                swingGroup.userData.baseAngle = angle;
                swingGroup.userData.chainGroup = chainGroup;
                
                swingContainer.add(swingGroup);
            }
            
            rotatingHub.add(swingContainer);
            rotatingHub.userData.swingContainer = swingContainer;
            
            // タワートップの装飾構造
            const topStructure = new THREE.Group();
            
            // トップキャップ
            const topCap = new THREE.Mesh(
                new THREE.ConeGeometry(3, 4.5, 16),
                materials.darkGray()
            );
            topCap.position.y = 33;
            topStructure.add(topCap);
            
            // 装飾的なアンテナ
            const antenna = helpers.createCylinder(0.15, 0.15, 3, materials.black());
            antenna.position.y = 36;
            topStructure.add(antenna);
            
            // 警告灯
            const warningLight = helpers.createSphere(0.4, 8, 8, materials.veryLightGray());
            warningLight.position.y = 37.5;
            topStructure.add(warningLight);
            
            group.add(topStructure);
            
            // 装飾フラッグ（風になびく）
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const flagPole = helpers.createCylinder(0.07, 0.07, 4, materials.black());
                flagPole.position.set(
                    Math.cos(angle) * 3.5,
                    31.5,
                    Math.sin(angle) * 3.5
                );
                
                // 三角形のフラッグ
                const flagGeometry = new THREE.BufferGeometry();
                const vertices = new Float32Array([
                    0, 0, 0,
                    2, -0.7, 0,
                    0, -1.4, 0
                ]);
                flagGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                const flag = new THREE.Line(flagGeometry, materials.line(0x666666));
                flag.position.set(
                    Math.cos(angle) * 3.5,
                    34.5,
                    Math.sin(angle) * 3.5
                );
                flag.userData.baseAngle = angle;
                
                group.add(flagPole);
                group.add(flag);
            }

            group.position.set(60, 0, -60);
            scene.add(group);
            animatedObjects.swingRide = group;
            group.userData.rotatingHub = rotatingHub;
            
            group.updateMatrixWorld(true);
            buildings.push(group);
        }

        // ローラーコースター（大幅に改良）
        function createRollerCoaster() {
            const group = new THREE.Group();

            // より複雑で現実的なトラックパス
            const curve = new THREE.CatmullRomCurve3([
                // スタート地点
                new THREE.Vector3(-25, 2, -25),
                new THREE.Vector3(-20, 4, -25),
                
                // 最初の上り坂
                new THREE.Vector3(-15, 8, -25),
                new THREE.Vector3(-10, 15, -25),
                new THREE.Vector3(-5, 22, -25),
                new THREE.Vector3(0, 28, -25),
                
                // 頂点からの急降下
                new THREE.Vector3(5, 26, -22),
                new THREE.Vector3(10, 20, -18),
                new THREE.Vector3(15, 12, -12),
                new THREE.Vector3(18, 8, -5),
                
                // スパイラル部分
                new THREE.Vector3(20, 6, 0),
                new THREE.Vector3(20, 8, 8),
                new THREE.Vector3(15, 12, 15),
                new THREE.Vector3(8, 16, 18),
                new THREE.Vector3(0, 18, 20),
                new THREE.Vector3(-8, 16, 18),
                new THREE.Vector3(-15, 12, 15),
                new THREE.Vector3(-20, 8, 8),
                
                // 第二の山
                new THREE.Vector3(-22, 10, 0),
                new THREE.Vector3(-20, 15, -8),
                new THREE.Vector3(-15, 18, -15),
                new THREE.Vector3(-8, 20, -18),
                new THREE.Vector3(0, 18, -20),
                
                // フィニッシュへの下り坂
                new THREE.Vector3(8, 14, -18),
                new THREE.Vector3(15, 10, -15),
                new THREE.Vector3(20, 6, -10),
                new THREE.Vector3(22, 4, -5),
                new THREE.Vector3(22, 3, 0),
                new THREE.Vector3(20, 2, 5),
                new THREE.Vector3(15, 2, 8),
                new THREE.Vector3(8, 2, 10),
                new THREE.Vector3(0, 2, 10),
                new THREE.Vector3(-8, 2, 8),
                new THREE.Vector3(-15, 2, 5),
                new THREE.Vector3(-20, 2, 0),
                new THREE.Vector3(-22, 2, -8),
                new THREE.Vector3(-25, 2, -15),
                new THREE.Vector3(-25, 2, -20),
                new THREE.Vector3(-25, 2, -25)
            ]);

            // デュアルレール（左右のレール）
            const leftRail = new THREE.Mesh(
                new THREE.TubeGeometry(curve, 300, 0.15, 6, false),
                materials.black()
            );
            leftRail.position.z = -0.75;
            group.add(leftRail);
            
            const rightRail = new THREE.Mesh(
                new THREE.TubeGeometry(curve, 300, 0.15, 6, false),
                materials.black()
            );
            rightRail.position.z = 0.75;
            group.add(rightRail);

            // レール間のクロスタイ
            for (let i = 0; i <= 1; i += 0.01) {
                const point = curve.getPoint(i);
                const tangent = curve.getTangent(i);
                const normal = new THREE.Vector3(0, 1, 0);
                const binormal = new THREE.Vector3().crossVectors(tangent, normal).normalize();
                
                const crossTie = helpers.createCylinder(0.08, 0.08, 1.8, materials.mediumGray());
                crossTie.position.copy(point);
                crossTie.lookAt(point.clone().add(binormal));
                crossTie.rotateX(Math.PI / 2);
                group.add(crossTie);
            }

            // 高度に詳細なサポート構造
            for (let i = 0; i <= 1; i += 0.03) {
                const point = curve.getPoint(i);
                if (point.y > 3) {
                    const supportHeight = point.y - 0.5;
                    
                    // メインサポートピラー
                    const mainSupport = helpers.createCylinder(0.3, 0.5, supportHeight, materials.lightGray());
                    mainSupport.position.set(point.x, supportHeight / 2, point.z);
                    group.add(mainSupport);
                    
                    // クロスブレース（X字型サポート）
                    if (supportHeight > 8) {
                        const brace1 = helpers.createCylinder(0.15, 0.15, supportHeight * 0.7, materials.mediumGray());
                        brace1.position.set(point.x - 2, supportHeight * 0.35, point.z);
                        brace1.rotation.z = 0.3;
                        group.add(brace1);
                        
                        const brace2 = helpers.createCylinder(0.15, 0.15, supportHeight * 0.7, materials.mediumGray());
                        brace2.position.set(point.x + 2, supportHeight * 0.35, point.z);
                        brace2.rotation.z = -0.3;
                        group.add(brace2);
                        
                        // 対角ブレース
                        const diagBrace1 = helpers.createCylinder(0.1, 0.1, 4, materials.gray());
                        diagBrace1.position.set(point.x, supportHeight * 0.7, point.z);
                        diagBrace1.rotation.x = Math.PI / 4;
                        group.add(diagBrace1);
                        
                        const diagBrace2 = helpers.createCylinder(0.1, 0.1, 4, materials.gray());
                        diagBrace2.position.set(point.x, supportHeight * 0.7, point.z);
                        diagBrace2.rotation.x = -Math.PI / 4;
                        group.add(diagBrace2);
                    }
                    
                    // サポート基礎
                    const foundation = helpers.createCylinder(1, 1.2, 1, materials.darkGray());
                    foundation.position.set(point.x, 0.5, point.z);
                    group.add(foundation);
                }
            }

            // 高品質なカート（2編成、各編成4両）
            for (let trainIndex = 0; trainIndex < 2; trainIndex++) {
                for (let carIndex = 0; carIndex < 4; carIndex++) {
                    const cartGroup = new THREE.Group();
                    
                    // カート本体
                    const cartBody = helpers.createBox(2, 1.2, 3, materials.darkGray());
                    cartBody.position.y = 0.6;
                    
                    // カートの座席（2列）
                    const frontSeat = helpers.createBox(1.8, 0.8, 1, materials.gray());
                    frontSeat.position.set(0, 1.2, 0.8);
                    const backSeat = helpers.createBox(1.8, 0.8, 1, materials.gray());
                    backSeat.position.set(0, 1.2, -0.8);
                    
                    // 安全バー
                    const safetyBar1 = helpers.createCylinder(0.05, 0.05, 1.8, materials.black());
                    safetyBar1.rotation.z = Math.PI / 2;
                    safetyBar1.position.set(0, 1.8, 0.8);
                    const safetyBar2 = helpers.createCylinder(0.05, 0.05, 1.8, materials.black());
                    safetyBar2.rotation.z = Math.PI / 2;
                    safetyBar2.position.set(0, 1.8, -0.8);
                    
                    // ホイール
                    const wheelPositions = [
                        [0.8, 0, 1.2], [-0.8, 0, 1.2],
                        [0.8, 0, -1.2], [-0.8, 0, -1.2]
                    ];
                    wheelPositions.forEach(pos => {
                        const wheel = helpers.createCylinder(0.3, 0.3, 0.2, materials.mediumGray());
                        wheel.rotation.z = Math.PI / 2;
                        wheel.position.set(...pos);
                        cartGroup.add(wheel);
                    });
                    
                    // カプラー（連結器）
                    if (carIndex < 3) {
                        const coupler = helpers.createCylinder(0.1, 0.1, 0.8, materials.black());
                        coupler.position.set(0, 0.3, -1.8);
                        cartGroup.add(coupler);
                    }
                    
                    cartGroup.add(cartBody);
                    cartGroup.add(frontSeat);
                    cartGroup.add(backSeat);
                    cartGroup.add(safetyBar1);
                    cartGroup.add(safetyBar2);
                    
                    cartGroup.userData.progress = (trainIndex * 0.5) + (carIndex * 0.05);
                    cartGroup.userData.curve = curve;
                    cartGroup.userData.trainIndex = trainIndex;
                    cartGroup.userData.carIndex = carIndex;
                    group.add(cartGroup);
                }
            }

            // 駅のプラットフォーム
            const station = new THREE.Group();
            const platform = helpers.createBox(15, 1, 8, materials.mediumGray());
            platform.position.set(-25, 0.5, -20);
            
            const stationRoof = helpers.createBox(17, 0.5, 10, materials.darkGray());
            stationRoof.position.set(-25, 4, -20);
            
            const stationPillars = [];
            for (let i = 0; i < 4; i++) {
                const pillar = helpers.createCylinder(0.3, 0.3, 3.5, materials.gray());
                pillar.position.set(-32 + i * 14, 1.75, -25 + i % 2 * 10);
                stationPillars.push(pillar);
                station.add(pillar);
            }
            
            station.add(platform);
            station.add(stationRoof);
            group.add(station);

            scene.add(group);
            animatedObjects.rollerCoaster = group;
        }

        // フリーフォール（大幅に改良）
        function createFreeFall() {
            const group = new THREE.Group();
            
            // 基盤構造
            const foundation = helpers.createBox(8, 2, 8, materials.darkGray());
            foundation.position.y = 1;
            group.add(foundation);
            
            // メインタワー（4本の支柱）
            const towerPositions = [
                [-2, 0, -2], [2, 0, -2], [-2, 0, 2], [2, 0, 2]
            ];
            
            towerPositions.forEach(pos => {
                const pillar = helpers.createBox(1, 45, 1, materials.mediumGray());
                pillar.position.set(pos[0], 22.5, pos[2]);
                group.add(pillar);
                
                // 支柱間のクロスブレース
                if (pos[0] === -2) {
                    for (let height = 5; height < 40; height += 8) {
                        const brace = helpers.createCylinder(0.15, 0.15, 4, materials.lightGray());
                        brace.rotation.x = Math.PI / 2;
                        brace.position.set(pos[0], height, 0);
                        group.add(brace);
                    }
                }
                if (pos[2] === -2) {
                    for (let height = 5; height < 40; height += 8) {
                        const brace = helpers.createCylinder(0.15, 0.15, 4, materials.lightGray());
                        brace.rotation.z = Math.PI / 2;
                        brace.position.set(0, height, pos[2]);
                        group.add(brace);
                    }
                }
            });
            
            // ガイドレール（上下移動用）
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const rail = helpers.createCylinder(0.1, 0.1, 40, materials.black());
                rail.position.set(
                    Math.cos(angle) * 3,
                    20,
                    Math.sin(angle) * 3
                );
                group.add(rail);
            }

            // 上部機械室
            const machineRoom = helpers.createBox(6, 4, 6, materials.darkGray());
            machineRoom.position.y = 42;
            group.add(machineRoom);
            
            // 巻き上げ機構（装飾）
            const winch = helpers.createCylinder(1.5, 1.5, 2, materials.black());
            winch.rotation.z = Math.PI / 2;
            winch.position.y = 42;
            group.add(winch);

            // 昇降プラットフォーム
            const platform = new THREE.Group();
            
            // プラットフォーム本体
            const platformBase = helpers.createCylinder(5, 5, 0.8, materials.gray());
            platform.add(platformBase);
            
            // プラットフォーム縁
            const platformEdge = helpers.createTorus(5, 0.3, 8, 32, Math.PI * 2, materials.mediumGray());
            platformEdge.rotation.x = Math.PI / 2;
            platformEdge.position.y = 0.4;
            platform.add(platformEdge);
            
            // 座席（12席）
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const seatGroup = new THREE.Group();
                
                // 座席本体
                const seatBase = helpers.createBox(1.2, 0.3, 1, materials.gray());
                seatBase.position.y = 0.65;
                
                // 座席の背もたれ
                const seatBack = helpers.createBox(1.2, 1.8, 0.2, materials.gray());
                seatBack.position.set(0, 1.5, -0.4);
                
                // 安全ハーネス
                const harness = helpers.createBox(1, 0.1, 0.8, materials.black());
                harness.position.set(0, 1.8, 0);
                
                // フットペダル
                const footPedal = helpers.createBox(1, 0.1, 0.3, materials.mediumGray());
                footPedal.position.set(0, 0.1, 0.6);
                
                seatGroup.add(seatBase);
                seatGroup.add(seatBack);
                seatGroup.add(harness);
                seatGroup.add(footPedal);
                
                seatGroup.position.set(
                    Math.cos(angle) * 3.5,
                    0,
                    Math.sin(angle) * 3.5
                );
                seatGroup.rotation.y = angle + Math.PI;
                platform.add(seatGroup);
            }
            
            // ケーブル（装飾）
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const cable = helpers.createCylinder(0.05, 0.05, 20, materials.darkGray());
                cable.position.set(
                    Math.cos(angle) * 2,
                    10,
                    Math.sin(angle) * 2
                );
                group.add(cable);
            }
            
            platform.userData.baseY = 8;
            platform.position.y = 8;
            group.add(platform);
            
            // タワートップの装飾
            const topStructure = helpers.createBox(8, 2, 8, materials.darkGray());
            topStructure.position.y = 46;
            group.add(topStructure);
            
            // 警告ライト
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const warningLight = helpers.createSphere(0.3, 6, 6, materials.veryLightGray());
                warningLight.position.set(
                    Math.cos(angle) * 4.5,
                    46,
                    Math.sin(angle) * 4.5
                );
                group.add(warningLight);
            }

            group.position.set(-60, 0, 0);
            scene.add(group);
            animatedObjects.freeFall = group;
            
            group.updateMatrixWorld(true);
            buildings.push(group);
        }

        // バイキングシップ（大幅に改良）
        function createVikingShip() {
            const group = new THREE.Group();
            
            // 基盤構造
            const foundation1 = helpers.createBox(6, 3, 6, materials.darkGray());
            foundation1.position.set(-15, 1.5, 0);
            group.add(foundation1);
            
            const foundation2 = helpers.createBox(6, 3, 6, materials.darkGray());
            foundation2.position.set(15, 1.5, 0);
            group.add(foundation2);
            
            // 支持タワー（A型フレーム）
            const leftTower = new THREE.Group();
            const rightTower = new THREE.Group();
            
            // 左タワー
            const leftPillar1 = helpers.createCylinder(0.8, 0.8, 20, materials.mediumGray());
            leftPillar1.position.set(-2, 10, 0);
            leftPillar1.rotation.z = 0.2;
            
            const leftPillar2 = helpers.createCylinder(0.8, 0.8, 20, materials.mediumGray());
            leftPillar2.position.set(2, 10, 0);
            leftPillar2.rotation.z = -0.2;
            
            const leftCrossBeam = helpers.createCylinder(0.4, 0.4, 5, materials.lightGray());
            leftCrossBeam.position.set(0, 18, 0);
            leftCrossBeam.rotation.z = Math.PI / 2;
            
            leftTower.add(leftPillar1);
            leftTower.add(leftPillar2);
            leftTower.add(leftCrossBeam);
            leftTower.position.set(-15, 0, 0);
            
            // 右タワー
            const rightPillar1 = helpers.createCylinder(0.8, 0.8, 20, materials.mediumGray());
            rightPillar1.position.set(-2, 10, 0);
            rightPillar1.rotation.z = 0.2;
            
            const rightPillar2 = helpers.createCylinder(0.8, 0.8, 20, materials.mediumGray());
            rightPillar2.position.set(2, 10, 0);
            rightPillar2.rotation.z = -0.2;
            
            const rightCrossBeam = helpers.createCylinder(0.4, 0.4, 5, materials.lightGray());
            rightCrossBeam.position.set(0, 18, 0);
            rightCrossBeam.rotation.z = Math.PI / 2;
            
            rightTower.add(rightPillar1);
            rightTower.add(rightPillar2);
            rightTower.add(rightCrossBeam);
            rightTower.position.set(15, 0, 0);
            
            group.add(leftTower);
            group.add(rightTower);
            
            // 回転軸とアーム
            const rotationHub = helpers.createCylinder(1.5, 1.5, 2, materials.black());
            rotationHub.rotation.z = Math.PI / 2;
            rotationHub.position.y = 18;
            group.add(rotationHub);
            
            // 巨大なアーム
            const armRadius = 18;
            const armStructure = helpers.createTorus(armRadius, 0.6, 8, 32, Math.PI, materials.mediumGray());
            armStructure.rotation.z = Math.PI;
            armStructure.position.y = 18;
            group.add(armStructure);
            
            // アームの補強
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI;
                const brace = helpers.createCylinder(0.3, 0.3, 4, materials.lightGray());
                brace.position.set(
                    Math.cos(angle) * (armRadius - 2),
                    18 + Math.sin(angle) * (armRadius - 2),
                    0
                );
                brace.rotation.z = angle;
                group.add(brace);
            }

            // 詳細なバイキングシップ
            const shipGroup = new THREE.Group();
            
            // 船体下部（キール）- より詳細な形状
            const keel = helpers.createBox(20, 2, 6, materials.darkGray());
            shipGroup.add(keel);
            
            // 船底の曲線部分
            const keelCurve1 = helpers.createBox(18, 1.5, 5.5, materials.darkGray());
            keelCurve1.position.y = -0.8;
            shipGroup.add(keelCurve1);
            
            const keelCurve2 = helpers.createBox(16, 1, 5, materials.darkGray());
            keelCurve2.position.y = -1.3;
            shipGroup.add(keelCurve2);
            
            // 船体側面（より詳細）
            const leftSide = helpers.createBox(20, 3.5, 0.5, materials.darkGray());
            leftSide.position.set(0, 1.75, 3);
            const rightSide = helpers.createBox(20, 3.5, 0.5, materials.darkGray());
            rightSide.position.set(0, 1.75, -3);
            shipGroup.add(leftSide);
            shipGroup.add(rightSide);
            
            // 船体の前後の傾斜部分
            const frontSlope = helpers.createBox(2, 3, 5, materials.darkGray());
            frontSlope.position.set(11, 1.5, 0);
            frontSlope.rotation.z = -0.3;
            shipGroup.add(frontSlope);
            
            const rearSlope = helpers.createBox(2, 3, 5, materials.darkGray());
            rearSlope.position.set(-11, 1.5, 0);
            rearSlope.rotation.z = 0.3;
            shipGroup.add(rearSlope);
            
            // 船首と船尾（より装飾的）
            const bowGroup = new THREE.Group();
            const bowBase = new THREE.Mesh(
                new THREE.ConeGeometry(3, 7, 8),
                materials.darkGray()
            );
            bowBase.rotation.z = -Math.PI / 2;
            bowBase.position.set(13.5, 3.5, 0);
            bowGroup.add(bowBase);
            
            // 船首の装飾リング
            for (let i = 0; i < 3; i++) {
                const ring = helpers.createTorus(2.5 - i * 0.4, 0.1, 6, 16, Math.PI * 2, materials.mediumGray());
                ring.rotation.y = Math.PI / 2;
                ring.position.set(12 + i * 1.5, 3.5, 0);
                bowGroup.add(ring);
            }
            shipGroup.add(bowGroup);
            
            const sternGroup = new THREE.Group();
            const sternBase = new THREE.Mesh(
                new THREE.ConeGeometry(3, 7, 8),
                materials.darkGray()
            );
            sternBase.rotation.z = Math.PI / 2;
            sternBase.position.set(-13.5, 3.5, 0);
            sternGroup.add(sternBase);
            
            // 船尾の装飾リング
            for (let i = 0; i < 3; i++) {
                const ring = helpers.createTorus(2.5 - i * 0.4, 0.1, 6, 16, Math.PI * 2, materials.mediumGray());
                ring.rotation.y = Math.PI / 2;
                ring.position.set(-12 - i * 1.5, 3.5, 0);
                sternGroup.add(ring);
            }
            shipGroup.add(sternGroup);
            
            // バイキングヘッド（船首装飾）- より詳細
            const vikingHeadGroup = new THREE.Group();
            
            // 頭部本体
            const vikingHead = helpers.createSphere(1.2, 10, 10, materials.gray());
            vikingHead.scale.set(1, 1.2, 0.8);
            
            // 目
            const leftEye = helpers.createSphere(0.2, 6, 6, materials.black());
            leftEye.position.set(0.4, 0.3, 0.7);
            const rightEye = helpers.createSphere(0.2, 6, 6, materials.black());
            rightEye.position.set(-0.4, 0.3, 0.7);
            
            // 鼻
            const nose = helpers.createCylinder(0.15, 0.1, 0.4, materials.mediumGray());
            nose.rotation.x = Math.PI / 2;
            nose.position.set(0, 0, 0.9);
            
            // 口（開いた状態）
            const mouth = helpers.createTorus(0.6, 0.1, 6, 8, Math.PI, materials.darkGray());
            mouth.rotation.x = Math.PI / 2;
            mouth.position.set(0, -0.3, 0.7);
            
            // 牙
            for (let i = -2; i <= 2; i++) {
                const fang = new THREE.Mesh(
                    new THREE.ConeGeometry(0.08, 0.3, 4),
                    materials.lightGray()
                );
                fang.position.set(i * 0.2, -0.3, 0.8);
                fang.rotation.x = 0.2;
                vikingHeadGroup.add(fang);
            }
            
            vikingHeadGroup.add(vikingHead);
            vikingHeadGroup.add(leftEye);
            vikingHeadGroup.add(rightEye);
            vikingHeadGroup.add(nose);
            vikingHeadGroup.add(mouth);
            
            // より立体的な角
            const vikingHorn1 = new THREE.Group();
            const horn1Base = helpers.createCylinder(0.2, 0.1, 2, materials.lightGray());
            horn1Base.position.y = 1;
            const horn1Tip = new THREE.Mesh(
                new THREE.ConeGeometry(0.1, 0.5, 6),
                materials.lightGray()
            );
            horn1Tip.position.y = 2.25;
            vikingHorn1.add(horn1Base);
            vikingHorn1.add(horn1Tip);
            vikingHorn1.position.set(0.5, 0.8, -0.3);
            vikingHorn1.rotation.z = -0.4;
            
            const vikingHorn2 = new THREE.Group();
            const horn2Base = helpers.createCylinder(0.2, 0.1, 2, materials.lightGray());
            horn2Base.position.y = 1;
            const horn2Tip = new THREE.Mesh(
                new THREE.ConeGeometry(0.1, 0.5, 6),
                materials.lightGray()
            );
            horn2Tip.position.y = 2.25;
            vikingHorn2.add(horn2Base);
            vikingHorn2.add(horn2Tip);
            vikingHorn2.position.set(-0.5, 0.8, -0.3);
            vikingHorn2.rotation.z = 0.4;
            
            vikingHeadGroup.add(vikingHorn1);
            vikingHeadGroup.add(vikingHorn2);
            vikingHeadGroup.position.set(17, 3.5, 0);
            shipGroup.add(vikingHeadGroup);
            
            // 船の装飾（側面のシールド）
            for (let i = 0; i < 8; i++) {
                const shieldAngle = (i / 8) * Math.PI * 1.6 - Math.PI * 0.8;
                const shield = helpers.createCylinder(0.8, 0.8, 0.2, materials.mediumGray());
                shield.rotation.x = Math.PI / 2;
                shield.position.set(
                    -7 + i * 2,
                    2.5,
                    3.2
                );
                
                // シールドの装飾
                const shieldCenter = helpers.createSphere(0.2, 6, 6, materials.darkGray());
                shieldCenter.position.copy(shield.position);
                shieldCenter.position.z = 3.3;
                
                shipGroup.add(shield);
                shipGroup.add(shieldCenter);
                
                // 反対側のシールド
                const shield2 = shield.clone();
                shield2.position.z = -3.2;
                const shieldCenter2 = shieldCenter.clone();
                shieldCenter2.position.z = -3.3;
                
                shipGroup.add(shield2);
                shipGroup.add(shieldCenter2);
            }
            
            // 座席（3列、各列8席）- より快適な座席
            for (let row = 0; row < 3; row++) {
                for (let seat = 0; seat < 8; seat++) {
                    const seatGroup = new THREE.Group();
                    
                    // 座席本体（より詳細）
                    const seatBase = helpers.createBox(1.6, 0.5, 1.3, materials.gray());
                    seatBase.position.y = 0.25;
                    
                    // 座席クッション
                    const seatCushion = helpers.createBox(1.5, 0.2, 1.2, materials.mediumGray());
                    seatCushion.position.y = 0.6;
                    
                    // 背もたれ（曲線的）
                    const seatBack = helpers.createBox(1.6, 2.2, 0.3, materials.gray());
                    seatBack.position.set(0, 1.3, -0.5);
                    seatBack.rotation.x = -0.1;
                    
                    // 背もたれクッション
                    const backCushion = helpers.createBox(1.4, 1.8, 0.15, materials.mediumGray());
                    backCushion.position.set(0, 1.3, -0.45);
                    backCushion.rotation.x = -0.1;
                    
                    // ヘッドレスト
                    const headrest = helpers.createCylinder(0.4, 0.4, 0.3, materials.darkGray());
                    headrest.rotation.x = Math.PI / 2;
                    headrest.position.set(0, 2.2, -0.5);
                    
                    // 安全バー（より詳細）
                    const safetyBarBase = helpers.createCylinder(0.1, 0.1, 1.6, materials.black());
                    safetyBarBase.rotation.z = Math.PI / 2;
                    safetyBarBase.position.set(0, 2, 0.4);
                    
                    // 安全バーのパッド
                    const safetyPad = helpers.createCylinder(0.15, 0.15, 1.2, materials.darkGray());
                    safetyPad.rotation.z = Math.PI / 2;
                    safetyPad.position.set(0, 2, 0.4);
                    
                    seatGroup.add(seatBase);
                    seatGroup.add(seatCushion);
                    seatGroup.add(seatBack);
                    seatGroup.add(backCushion);
                    seatGroup.add(headrest);
                    seatGroup.add(safetyBarBase);
                    seatGroup.add(safetyPad);
                    
                    seatGroup.position.set(
                        -7 + seat * 2,
                        0.5,
                        -1.5 + row * 1.5
                    );
                    shipGroup.add(seatGroup);
                }
            }
            
            // 船のマスト（より詳細）
            const mastGroup = new THREE.Group();
            const mast = helpers.createCylinder(0.4, 0.5, 10, materials.black());
            mast.position.set(0, 6, 0);
            mastGroup.add(mast);
            
            // マストの横棒
            const crossBeam = helpers.createCylinder(0.2, 0.2, 10, materials.darkGray());
            crossBeam.rotation.z = Math.PI / 2;
            crossBeam.position.set(0, 8, 0);
            mastGroup.add(crossBeam);
            
            // マストトップの装飾
            const mastTop = helpers.createSphere(0.3, 8, 8, materials.gold());
            mastTop.position.set(0, 11, 0);
            mastGroup.add(mastTop);
            
            shipGroup.add(mastGroup);
            
            // セイル（より詳細なワイヤーフレーム）
            const sailGroup = new THREE.Group();
            
            // メインセイル
            const sail = helpers.createBox(0.1, 7, 9, materials.veryLightGray());
            sail.position.set(0, 6, 0);
            sailGroup.add(sail);
            
            // セイルの格子模様
            for (let i = -4; i <= 4; i++) {
                const horizontalLine = helpers.createCylinder(0.05, 0.05, 9, materials.lightGray());
                horizontalLine.rotation.z = Math.PI / 2;
                horizontalLine.position.set(0, 6 + i * 0.8, 0);
                sailGroup.add(horizontalLine);
            }
            
            for (let i = -4; i <= 4; i++) {
                const verticalLine = helpers.createCylinder(0.05, 0.05, 7, materials.lightGray());
                verticalLine.position.set(0, 6, i);
                sailGroup.add(verticalLine);
            }
            
            shipGroup.add(sailGroup);
            
            // ロープ（より詳細）
            for (let i = 0; i < 6; i++) {
                const rope = helpers.createCylinder(0.06, 0.06, 12, materials.lightGray());
                rope.position.set(i * 3 - 7.5, 4, 0);
                rope.rotation.x = 0.3;
                rope.rotation.z = i % 2 === 0 ? 0.1 : -0.1;
                shipGroup.add(rope);
                
                // ロープの結び目
                const knot = helpers.createSphere(0.15, 6, 6, materials.mediumGray());
                knot.position.set(i * 3 - 7.5, 8, -2);
                shipGroup.add(knot);
            }
            
            // 船の手すり
            const railingLeft = helpers.createCylinder(0.08, 0.08, 18, materials.mediumGray());
            railingLeft.rotation.z = Math.PI / 2;
            railingLeft.position.set(0, 3.5, 3.2);
            shipGroup.add(railingLeft);
            
            const railingRight = helpers.createCylinder(0.08, 0.08, 18, materials.mediumGray());
            railingRight.rotation.z = Math.PI / 2;
            railingRight.position.set(0, 3.5, -3.2);
            shipGroup.add(railingRight);

            shipGroup.position.y = 18;
            shipGroup.userData.swingAngle = 0;
            group.add(shipGroup);
            group.userData.shipGroup = shipGroup;

            group.position.set(60, 0, 0);
            scene.add(group);
            animatedObjects.vikingShip = group;
            
            group.updateMatrixWorld(true);
            buildings.push(group);
        }

        // ゴーカート（大幅に改良）
        function createGoKarts() {
            const group = new THREE.Group();
            
            // より詳細なトラック
            const trackPoints = [];
            for (let i = 0; i <= 32; i++) {
                const angle = (i / 32) * Math.PI * 2;
                const radius = 15 + Math.sin(angle * 3) * 5;
                trackPoints.push(new THREE.Vector3(
                    Math.cos(angle) * radius,
                    0.1,
                    Math.sin(angle) * radius
                ));
            }
            const trackCurve = new THREE.CatmullRomCurve3(trackPoints);
            
            // デュアルトラック（内側と外側のレーン）
            const innerTrack = new THREE.Mesh(
                new THREE.TubeGeometry(trackCurve, 64, 0.3, 6, true),
                materials.darkGray()
            );
            innerTrack.position.z = -1;
            group.add(innerTrack);
            
            const outerTrack = new THREE.Mesh(
                new THREE.TubeGeometry(trackCurve, 64, 0.3, 6, true),
                materials.darkGray()
            );
            outerTrack.position.z = 1;
            group.add(outerTrack);
            
            // トラック境界線
            const centerLine = new THREE.Mesh(
                new THREE.TubeGeometry(trackCurve, 64, 0.05, 4, true),
                materials.veryLightGray()
            );
            group.add(centerLine);

            // 高品質ゴーカート（6台）
            for (let i = 0; i < 6; i++) {
                const kartGroup = new THREE.Group();
                
                // カート本体（より詳細）
                const kartChassis = helpers.createBox(1.8, 0.3, 2.8, materials.gray());
                kartChassis.position.y = 0.4;
                
                // フロントノーズ
                const frontNose = helpers.createBox(1.4, 0.25, 0.8, materials.lightGray());
                frontNose.position.set(0, 0.5, 1.8);
                
                // コックピット
                const cockpit = helpers.createBox(1.2, 0.8, 1.5, materials.darkGray());
                cockpit.position.set(0, 0.8, 0);
                
                // 座席
                const seat = helpers.createBox(0.8, 0.6, 0.8, materials.mediumGray());
                seat.position.set(0, 1.1, -0.2);
                
                // ステアリングホイール
                const steeringWheel = helpers.createTorus(0.3, 0.05, 8, 16, Math.PI * 2, materials.black());
                steeringWheel.rotation.x = Math.PI / 3;
                steeringWheel.position.set(0, 1.3, 0.5);
                
                // ロールバー
                const rollBar1 = helpers.createCylinder(0.08, 0.08, 1.5, materials.black());
                rollBar1.position.set(-0.5, 1.5, -0.5);
                const rollBar2 = helpers.createCylinder(0.08, 0.08, 1.5, materials.black());
                rollBar2.position.set(0.5, 1.5, -0.5);
                const rollBarTop = helpers.createCylinder(0.08, 0.08, 1, materials.black());
                rollBarTop.rotation.z = Math.PI / 2;
                rollBarTop.position.set(0, 2.2, -0.5);
                
                // ホイール（4つ）
                const wheelPositions = [
                    [0.8, 0.2, 1.2], [-0.8, 0.2, 1.2],  // 前輪
                    [0.8, 0.2, -1.2], [-0.8, 0.2, -1.2]  // 後輪
                ];
                wheelPositions.forEach(pos => {
                    const wheelGroup = new THREE.Group();
                    
                    // タイヤ
                    const tire = helpers.createCylinder(0.35, 0.35, 0.25, materials.black());
                    tire.rotation.z = Math.PI / 2;
                    
                    // リム
                    const rim = helpers.createCylinder(0.25, 0.25, 0.3, materials.lightGray());
                    rim.rotation.z = Math.PI / 2;
                    
                    wheelGroup.add(tire);
                    wheelGroup.add(rim);
                    wheelGroup.position.set(...pos);
                    kartGroup.add(wheelGroup);
                });
                
                // エンジン（後部）
                const engine = helpers.createBox(0.8, 0.6, 0.8, materials.darkGray());
                engine.position.set(0, 0.7, -1.5);
                
                // 排気パイプ
                const exhaust = helpers.createCylinder(0.08, 0.08, 0.5, materials.mediumGray());
                exhaust.rotation.x = Math.PI / 2;
                exhaust.position.set(0.3, 0.7, -2.2);
                
                // 番号（装飾）
                const numberPlate = helpers.createBox(0.5, 0.3, 0.05, materials.veryLightGray());
                numberPlate.position.set(0, 1, 1.9);
                
                kartGroup.add(kartChassis);
                kartGroup.add(frontNose);
                kartGroup.add(cockpit);
                kartGroup.add(seat);
                kartGroup.add(steeringWheel);
                kartGroup.add(rollBar1);
                kartGroup.add(rollBar2);
                kartGroup.add(rollBarTop);
                kartGroup.add(engine);
                kartGroup.add(exhaust);
                kartGroup.add(numberPlate);
                
                kartGroup.userData.progress = i * 0.16;
                kartGroup.userData.curve = trackCurve;
                kartGroup.userData.lane = i % 2; // 内側または外側のレーン
                group.add(kartGroup);
            }

            group.position.set(-60, 0, 40);
            scene.add(group);
            animatedObjects.goKarts = group;
        }

        // ミニトレイン（大幅に改良）
        function createMiniTrain() {
            const group = new THREE.Group();
            
            // より詳細なトラック
            const trackCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-70, 0.5, -70),
                new THREE.Vector3(-70, 0.5, -20),
                new THREE.Vector3(-70, 0.5, 20),
                new THREE.Vector3(-70, 0.5, 70),
                new THREE.Vector3(-20, 0.5, 70),
                new THREE.Vector3(20, 0.5, 70),
                new THREE.Vector3(70, 0.5, 70),
                new THREE.Vector3(70, 0.5, 20),
                new THREE.Vector3(70, 0.5, -20),
                new THREE.Vector3(70, 0.5, -70),
                new THREE.Vector3(20, 0.5, -70),
                new THREE.Vector3(-20, 0.5, -70),
                new THREE.Vector3(-70, 0.5, -70)
            ]);

            // デュアルレール
            const leftRail = new THREE.Mesh(
                new THREE.TubeGeometry(trackCurve, 200, 0.08, 6, true),
                materials.mediumGray()
            );
            leftRail.position.z = -0.4;
            group.add(leftRail);
            
            const rightRail = new THREE.Mesh(
                new THREE.TubeGeometry(trackCurve, 200, 0.08, 6, true),
                materials.mediumGray()
            );
            rightRail.position.z = 0.4;
            group.add(rightRail);
            
            // 枕木
            for (let i = 0; i <= 1; i += 0.02) {
                const point = trackCurve.getPoint(i);
                const tangent = trackCurve.getTangent(i);
                const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                
                const crosstie = helpers.createBox(0.15, 0.1, 1.2, materials.lightGray());
                crosstie.position.copy(point);
                crosstie.position.y = 0.4;
                crosstie.lookAt(point.clone().add(tangent));
                group.add(crosstie);
            }

            // 高品質トレイン編成（機関車 + 3両の客車）
            const trainGroup = new THREE.Group();
            
            // 機関車（先頭車両）
            const locomotive = new THREE.Group();
            
            // 機関車本体
            const locoBody = helpers.createBox(2.5, 2, 3.5, materials.darkGray());
            locoBody.position.y = 1.5;
            locomotive.add(locoBody);
            
            // 機関車のボイラー
            const boiler = helpers.createCylinder(0.8, 0.8, 3, materials.mediumGray());
            boiler.rotation.z = Math.PI / 2;
            boiler.position.set(0, 2.2, 0.5);
            locomotive.add(boiler);
            
            // 煙突
            const smokestack = helpers.createCylinder(0.3, 0.4, 1.5, materials.black());
            smokestack.position.set(0, 3.5, 1.2);
            locomotive.add(smokestack);
            
            // 機関車の前面（カウキャッチャー）
            const cowcatcher = new THREE.Mesh(
                new THREE.ConeGeometry(1, 1, 4),
                materials.gray()
            );
            cowcatcher.rotation.x = Math.PI;
            cowcatcher.position.set(0, 0.8, 2.2);
            locomotive.add(cowcatcher);
            
            // ヘッドライト
            const headlight = helpers.createSphere(0.3, 8, 8, materials.veryLightGray());
            headlight.position.set(0, 2, 2.5);
            locomotive.add(headlight);
            
            // 機関車の運転室
            const cabin = helpers.createBox(2, 1.5, 1.5, materials.gray());
            cabin.position.set(0, 2.5, -1);
            locomotive.add(cabin);
            
            // 機関車の窓
            const frontWindow = helpers.createBox(1.5, 1, 0.1, materials.transparent(0x666666, 0.3));
            frontWindow.position.set(0, 2.5, -0.2);
            locomotive.add(frontWindow);
            
            // 機関車の車輪（4つ）
            for (let w = 0; w < 4; w++) {
                const wheel = helpers.createCylinder(0.5, 0.5, 0.2, materials.black());
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(
                    w % 2 === 0 ? -1.1 : 1.1,
                    0.5,
                    w < 2 ? 0.8 : -0.8
                );
                locomotive.add(wheel);
            }
            
            trainGroup.add(locomotive);
            
            // 客車（3両）
            for (let carIndex = 0; carIndex < 3; carIndex++) {
                const passengerCar = new THREE.Group();
                
                // 客車本体
                const carBody = helpers.createBox(2, 1.8, 3, materials.gray());
                carBody.position.y = 1.4;
                passengerCar.add(carBody);
                
                // 客車の屋根
                const carRoof = helpers.createBox(2.2, 0.3, 3.2, materials.mediumGray());
                carRoof.position.y = 2.4;
                passengerCar.add(carRoof);
                
                // 客車の窓（両側に3つずつ）
                for (let side = 0; side < 2; side++) {
                    for (let windowIndex = 0; windowIndex < 3; windowIndex++) {
                        const window = helpers.createBox(0.6, 0.8, 0.05, materials.transparent(0x666666, 0.3));
                        window.position.set(
                            side === 0 ? -1.05 : 1.05,
                            1.6,
                            -1 + windowIndex * 1
                        );
                        passengerCar.add(window);
                    }
                }
                
                // 客車のドア
                const door = helpers.createBox(0.8, 1.5, 0.05, materials.lightGray());
                door.position.set(0, 1.5, -1.55);
                passengerCar.add(door);
                
                // 客車の車輪（4つ）
                for (let w = 0; w < 4; w++) {
                    const wheel = helpers.createCylinder(0.4, 0.4, 0.15, materials.black());
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(
                        w % 2 === 0 ? -0.9 : 0.9,
                        0.4,
                        w < 2 ? 1 : -1
                    );
                    passengerCar.add(wheel);
                }
                
                // 連結器
                if (carIndex < 2) {
                    const coupler = helpers.createCylinder(0.1, 0.1, 0.8, materials.black());
                    coupler.rotation.x = Math.PI / 2;
                    coupler.position.set(0, 1, -1.8);
                    passengerCar.add(coupler);
                }
                
                // 客車を機関車の後ろに配置
                passengerCar.position.z = -(carIndex + 1) * 4.5;
                trainGroup.add(passengerCar);
            }

            trainGroup.userData.progress = 0;
            trainGroup.userData.curve = trackCurve;
            group.add(trainGroup);

            scene.add(group);
            animatedObjects.trainTrack = group;
        }

        // ティーカップ
        function createTeacups() {
            const group = new THREE.Group();
            
            const base = helpers.createCylinder(10, 10, 0.5, materials.darkGray());
            group.add(base);

            // ティーカップ
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const cupGroup = new THREE.Group();
                
                const cup = helpers.createCylinder(2, 1.5, 2, materials.gray());
                cup.position.y = 1;
                
                const handle = helpers.createTorus(1, 0.2, 8, 8, Math.PI, materials.gray());
                handle.rotation.z = -Math.PI / 2;
                handle.position.set(1.8, 1, 0);
                
                cupGroup.add(cup);
                cupGroup.add(handle);
                cupGroup.position.set(
                    Math.cos(angle) * 7,
                    0,
                    Math.sin(angle) * 7
                );
                cupGroup.userData.spinSpeed = Math.random() * 0.02 + 0.01;
                group.add(cupGroup);
            }

            group.position.set(-30, 0, 30);
            scene.add(group);
            animatedObjects.teacups = group;
            
            // ワールド座標を更新してから建物リストに追加
            group.updateMatrixWorld(true);
            buildings.push(group);
        }

        // 木々
        function createTrees() {
            // スタート地点に近いものを除外
            const treePositions = [
                [-65, 0, -15], [50, 0, -50],  // 観覧車下の木を左斜め手前に移動
                [-25, 0, 0], [25, 0, 0], [0, 0, -25]
            ];

            treePositions.forEach(pos => {
                const tree = new THREE.Group();
                
                const trunk = helpers.createCylinder(0.5, 0.7, 4, materials.mediumGray());
                trunk.position.y = 2;
                tree.add(trunk);

                const leaves = new THREE.Mesh(
                    new THREE.ConeGeometry(3, 6, 8),
                    materials.darkGray()
                );
                leaves.position.y = 6;
                tree.add(leaves);

                tree.position.set(...pos);
                scene.add(tree);
                
                // ワールド座標を更新してから建物リストに追加
                tree.updateMatrixWorld(true);
                buildings.push(tree);
            });
        }

        // ベンチ
        function createBenches() {
            // メインのベンチ（スタート地点近くのものを除外）
            const mainBenchPositions = [
                [-20, 0, 0], [20, 0, 0], [0, 0, -20]  // [0, 0, 20]を削除
            ];

            mainBenchPositions.forEach(pos => {
                const bench = new THREE.Group();
                
                const seat = helpers.createBox(3, 0.2, 1, materials.lightGray());
                seat.position.y = 0.5;
                bench.add(seat);

                const back = helpers.createBox(3, 1, 0.2, materials.lightGray());
                back.position.set(0, 1, -0.4);
                bench.add(back);

                bench.position.set(...pos);
                bench.rotation.y = Math.atan2(pos[2], pos[0]) + Math.PI / 2;
                scene.add(bench);
            });

            // 追加のベンチ（数を半分に減らして配置）
            const additionalBenchPositions = [
                [-45, 0, -20], [45, 0, 20],
                [-35, 0, -35], [35, 0, 35],
                [55, 0, 0],
                [0, 0, -55]
            ];

            additionalBenchPositions.forEach(pos => {
                const bench = new THREE.Group();
                
                const seat = helpers.createBox(2.5, 0.2, 0.8, materials.lightGray());
                seat.position.y = 0.5;
                bench.add(seat);

                const back = helpers.createBox(2.5, 0.8, 0.15, materials.lightGray());
                back.position.set(0, 0.9, -0.325);
                bench.add(back);

                // 肘掛け
                const armRest1 = helpers.createBox(0.1, 0.4, 0.8, materials.lightGray());
                armRest1.position.set(-1.2, 0.7, 0);
                bench.add(armRest1);

                const armRest2 = helpers.createBox(0.1, 0.4, 0.8, materials.lightGray());
                armRest2.position.set(1.2, 0.7, 0);
                bench.add(armRest2);

                bench.position.set(...pos);
                
                // ベンチを円の中心に向ける
                const angle = Math.atan2(pos[2], pos[0]);
                bench.rotation.y = angle + Math.PI / 2;
                
                scene.add(bench);
            });

            // ダブルベンチ（背中合わせ）- 観覧車の土台の中にあるものを削除
            const doubleBenchPositions = [
                [50, 0, -50]  // 観覧車の位置にあった[-50, 0, -50]を削除
            ];

            doubleBenchPositions.forEach(pos => {
                const benchGroup = new THREE.Group();
                
                // 中央の背もたれ
                const centerBack = helpers.createBox(3, 1.2, 0.3, materials.mediumGray());
                centerBack.position.y = 0.6;
                benchGroup.add(centerBack);

                // 両側のシート
                const seat1 = helpers.createBox(3, 0.2, 1, materials.lightGray());
                seat1.position.set(0, 0.5, 0.65);
                benchGroup.add(seat1);

                const seat2 = helpers.createBox(3, 0.2, 1, materials.lightGray());
                seat2.position.set(0, 0.5, -0.65);
                benchGroup.add(seat2);

                benchGroup.position.set(...pos);
                benchGroup.rotation.y = Math.random() * Math.PI;
                scene.add(benchGroup);
            });
        }

        // 街灯
        function createLamps() {
            // スタート地点に近いものを除外
            const lampPositions = [
                [-40, 0, 0], [40, 0, 0], [0, 0, -40],  // スタート地点近くの街灯は既に削除済み
                [-40, 0, -40], [40, 0, -40]
            ];

            lampPositions.forEach(pos => {
                const lamp = new THREE.Group();
                
                const pole = helpers.createCylinder(0.1, 0.1, 6, materials.gray());
                pole.position.y = 3;
                lamp.add(pole);

                const light = helpers.createSphere(0.5, 8, 8, materials.darkGray());
                light.position.y = 6;
                lamp.add(light);

                const pointLight = new THREE.PointLight(0x666666, 0.2, 10);
                pointLight.position.y = 6;
                lamp.add(pointLight);

                lamp.position.set(...pos);
                scene.add(lamp);
            });
        }



        // 月
        function createMoon() {
            const moonGroup = new THREE.Group();
            
            const moon = helpers.createSphere(25, 24, 24, materials.transparentNoFog(0x888888, 0.4));
            moonGroup.add(moon);

            // 緯度線
            for (let i = 1; i < 6; i++) {
                const latitude = (i / 6) * Math.PI;
                const radius = 25 * Math.sin(latitude);
                const y = 25 * Math.cos(latitude);
                
                const latLine = new THREE.Mesh(
                    new THREE.RingGeometry(radius - 0.1, radius + 0.1, 32),
                    materials.transparentNoFog(0x999999, 0.2)
                );
                latLine.position.y = y;
                latLine.rotation.x = Math.PI / 2;
                moonGroup.add(latLine);
            }

            moonGroup.position.set(-150, 140, -150);  // 高さを100から140に変更
            moonGroup.userData.rotationSpeed = 0.0001;
            scene.add(moonGroup);
        }

        // 星座
        function createConstellations() {
            const constellationsGroup = new THREE.Group();
            
            // 多様な星座パターン（7-9個の星で構成）
            const patterns = [
                // 大熊座風（8個）
                { stars: [[-4, 4], [-2, 5], [0, 4], [2, 3], [3, 0], [2, -2], [0, -3], [-2, -2]], 
                  lines: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 0], [3, 6]] },
                
                // オリオン座風（9個）
                { stars: [[-3, 6], [3, 6], [-4, 2], [0, 2], [4, 2], [-3, -2], [0, -3], [3, -2], [0, -6]], 
                  lines: [[0, 2], [1, 4], [2, 3], [3, 4], [2, 5], [4, 7], [5, 6], [6, 7], [6, 8]] },
                
                // 白鳥座風（8個）
                { stars: [[0, 6], [-4, 2], [-2, 0], [0, 0], [2, 0], [4, 2], [0, -2], [0, -5]], 
                  lines: [[0, 3], [1, 2], [2, 3], [3, 4], [4, 5], [3, 6], [6, 7], [1, 3], [3, 5]] },
                
                // 竜座風（9個）
                { stars: [[-4, 4], [-2, 6], [2, 6], [4, 4], [5, 0], [4, -4], [0, -2], [-2, -4], [-4, 0]], 
                  lines: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 0], [6, 8]] },
                
                // カシオペア座風（7個）
                { stars: [[-6, 2], [-4, 4], [-2, 3], [0, 4], [2, 3], [4, 4], [6, 2]], 
                  lines: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [2, 4], [1, 3], [3, 5]] },
                
                // ペガサス座風（9個）
                { stars: [[-4, 4], [0, 6], [4, 4], [4, 0], [2, -2], [0, -4], [-2, -2], [-4, 0], [0, 2]], 
                  lines: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 0], [8, 0], [8, 1], [8, 2], [8, 7]] }
            ];
            
            // 星座作成ヘルパー
            const createConstellation = (pattern, position, scale, rotation = 0) => {
                const constellation = new THREE.Group();
                
                // 星を作成
                pattern.stars.forEach(([x, y]) => {
                    const star = helpers.createSphere(0.12, 6, 6, materials.transparentNoFog(0x555555, 0.7));
                    star.position.set(x * scale, y * scale, 0);
                    star.userData.twinkleOffset = Math.random() * Math.PI * 2;
                    star.userData.twinkleSpeed = 0.002 + Math.random() * 0.003;
                    constellation.add(star);
                });
                
                // 線を作成
                pattern.lines.forEach(([start, end]) => {
                    const linePoints = [
                        new THREE.Vector3(pattern.stars[start][0] * scale, pattern.stars[start][1] * scale, 0),
                        new THREE.Vector3(pattern.stars[end][0] * scale, pattern.stars[end][1] * scale, 0)
                    ];
                    constellation.add(helpers.createLine(linePoints, materials.lineNoFog(0x777777, 0.4)));
                });
                
                constellation.position.copy(position);
                constellation.rotation.y = rotation;
                constellation.lookAt(0, constellation.position.y, 0);
                constellation.userData.baseRotationZ = constellation.rotation.z;
                constellation.userData.animSpeed = 0.1 + Math.random() * 0.2;
                constellation.userData.isConstellation = true;
                
                return constellation;
            };
            
            // フィールドを囲むように円形に配置
            // 内側の円（10個）
            const innerRadius = 85;
            const innerCount = 10;
            for (let i = 0; i < innerCount; i++) {
                const angle = (i / innerCount) * Math.PI * 2;
                const radius = innerRadius + Math.random() * 10;
                const height = 5 + Math.random() * 45;
                
                const position = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                const scale = 1.2 + Math.random() * 0.8;
                constellationsGroup.add(createConstellation(
                    patterns[i % patterns.length],
                    position,
                    scale,
                    angle + Math.PI / 2
                ));
            }
            
            // 中間の円（12個）
            const middleRadius = 105;
            const middleCount = 12;
            for (let i = 0; i < middleCount; i++) {
                const angle = (i / middleCount) * Math.PI * 2 + Math.PI / middleCount;
                const radius = middleRadius + Math.random() * 10;
                const height = 15 + Math.random() * 60;
                
                const position = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                const scale = 1.4 + Math.random() * 0.9;
                constellationsGroup.add(createConstellation(
                    patterns[(i + 3) % patterns.length],
                    position,
                    scale,
                    angle + Math.PI / 2
                ));
            }
            
            // 外側の円（14個）
            const outerRadius = 125;
            const outerCount = 14;
            for (let i = 0; i < outerCount; i++) {
                const angle = (i / outerCount) * Math.PI * 2;
                const radius = outerRadius + Math.random() * 15;
                const height = 25 + Math.random() * 65;
                
                const position = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                const scale = 1.6 + Math.random() * 1.0;
                constellationsGroup.add(createConstellation(
                    patterns[(i + 6) % patterns.length],
                    position,
                    scale,
                    angle + Math.PI / 2
                ));
            }
            
            // 天頂付近の星座（6個）
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const radius = 20 + Math.random() * 40;
                const height = 85 + Math.random() * 25;  // 85〜110mの高さ
                
                const position = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                const scale = 1.5 + Math.random() * 0.8;
                const constellation = createConstellation(
                    patterns[i % patterns.length],
                    position,
                    scale,
                    0
                );
                
                // 天頂の星座は水平に配置
                constellation.rotation.x = -Math.PI / 2;
                constellationsGroup.add(constellation);
            }
            
            scene.add(constellationsGroup);
            animatedObjects.constellations = constellationsGroup;
        }

        // 星
        function createStars() {
            // ランダムに散らばった星（星座を引き立てるため数を減らす）
            for (let i = 0; i < 120; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 100 + Math.random() * 60;
                const height = 10 + Math.random() * 80;
                
                const star = helpers.createSphere(
                    0.15 + Math.random() * 0.25,
                    4,
                    4,
                    materials.transparentNoFog(0x666666, 0.5 + Math.random() * 0.3)
                );
                
                star.position.set(
                    Math.cos(angle) * distance,
                    height,
                    Math.sin(angle) * distance
                );
                
                star.userData.twinkleOffset = Math.random() * Math.PI * 2;
                star.userData.twinkleSpeed = 0.001 + Math.random() * 0.004;
                star.userData.isStar = true;
                
                scene.add(star);
            }
            
            // 真上（天頂）付近の星を追加
            for (let i = 0; i < 60; i++) {
                const star = helpers.createSphere(
                    0.15 + Math.random() * 0.25,
                    4,
                    4,
                    materials.transparentNoFog(0x666666, 0.5 + Math.random() * 0.3)
                );
                
                // 真上付近にランダムに配置
                const radius = Math.random() * 80;
                const angle = Math.random() * Math.PI * 2;
                star.position.set(
                    Math.cos(angle) * radius,
                    80 + Math.random() * 40,  // 80〜120mの高さ
                    Math.sin(angle) * radius
                );
                
                star.userData.twinkleOffset = Math.random() * Math.PI * 2;
                star.userData.twinkleSpeed = 0.001 + Math.random() * 0.004;
                star.userData.isStar = true;
                
                scene.add(star);
            }
        }

        // ターゲット作成
        function createTargets() {
            const placedPositions = []; // 既に配置されたターゲットの位置を記録
            const minDistance = 20; // ターゲット間の最小距離（大幅に増加）
            const minBuildingDistance = 8; // 建物からの最小距離（少し増加）
            
            // フィールドを4つの象限に分けて管理
            const quadrants = {
                leftFront: [],   // X < 0, Z > 0 (左前)
                rightFront: [],  // X > 0, Z > 0 (右前)
                leftBack: [],    // X < 0, Z < 0 (左奥)
                rightBack: []    // X > 0, Z < 0 (右奥)
            };
            
            // 各象限に配置すべきターゲット数（合計20個を4象限に分配）
            const targetsPerQuadrant = 5;
            
            for (let i = 0; i < 20; i++) {
                const targetGroup = new THREE.Group();
                
                // 複雑なワイヤーフレームターゲット（サイズをさらに小さく）
                const outerGeometry = new THREE.TorusGeometry(1.5, 0.15, 8, 16);
                const middleGeometry = new THREE.TorusGeometry(0.9, 0.1, 6, 12);
                const innerGeometry = new THREE.OctahedronGeometry(0.4);
                
                const material = new THREE.MeshBasicMaterial({
                    color: 0x553322,  // 暗めのブロンズ系の色
                    wireframe: true
                });
                
                const outerMesh = new THREE.Mesh(outerGeometry, material);
                const middleMesh = new THREE.Mesh(middleGeometry, material);
                const innerMesh = new THREE.Mesh(innerGeometry, material);
                
                targetGroup.add(outerMesh);
                targetGroup.add(middleMesh);
                targetGroup.add(innerMesh);
                
                // 適切な位置を見つけるまでループ
                let position;
                let attempts = 0;
                const maxAttempts = 500;
                
                do {
                    // どの象限に配置するかを決定
                    let targetQuadrant = null;
                    
                    // 各象限の充足率を計算
                    const quadrantCounts = {
                        leftFront: quadrants.leftFront.length,
                        rightFront: quadrants.rightFront.length,
                        leftBack: quadrants.leftBack.length,
                        rightBack: quadrants.rightBack.length
                    };
                    
                    // 最も少ない象限を優先
                    let minCount = Math.min(...Object.values(quadrantCounts));
                    const underfilledQuadrants = Object.keys(quadrantCounts).filter(
                        q => quadrantCounts[q] === minCount && quadrantCounts[q] < targetsPerQuadrant
                    );
                    
                    if (underfilledQuadrants.length > 0) {
                        // 不足している象限からランダムに選択
                        targetQuadrant = underfilledQuadrants[Math.floor(Math.random() * underfilledQuadrants.length)];
                    } else {
                        // すべての象限が均等な場合はランダム
                        const quadrantNames = Object.keys(quadrants);
                        targetQuadrant = quadrantNames[Math.floor(Math.random() * quadrantNames.length)];
                    }
                    
                    // 選択された象限内での位置を生成
                    let x, z;
                    const margin = 10; // 象限の境界から少し離す
                    
                    switch(targetQuadrant) {
                        case 'leftFront':
                            x = -margin - Math.random() * (95 - margin);  // -10 ~ -95
                            z = margin + Math.random() * (95 - margin);   // 10 ~ 95
                            break;
                        case 'rightFront':
                            x = margin + Math.random() * (95 - margin);   // 10 ~ 95
                            z = margin + Math.random() * (95 - margin);   // 10 ~ 95
                            break;
                        case 'leftBack':
                            x = -margin - Math.random() * (95 - margin);  // -10 ~ -95
                            z = -margin - Math.random() * (95 - margin);  // -10 ~ -95
                            break;
                        case 'rightBack':
                            x = margin + Math.random() * (95 - margin);   // 10 ~ 95
                            z = -margin - Math.random() * (95 - margin);  // -10 ~ -95
                            break;
                    }
                    
                    position = new THREE.Vector3(x, 0, z);
                    
                    // 高さをより多様に（地面近くから高い場所まで）
                    const heightVariation = Math.random();
                    let height;
                    
                    if (heightVariation < 0.2) {
                        // 20%は低い位置（1〜4m）
                        height = Math.random() * 3 + 1;
                    } else if (heightVariation < 0.4) {
                        // 20%は中低位置（4〜8m）
                        height = Math.random() * 4 + 4;
                    } else if (heightVariation < 0.6) {
                        // 20%は中高位置（8〜15m）
                        height = Math.random() * 7 + 8;
                    } else if (heightVariation < 0.8) {
                        // 20%は高い位置（15〜25m）
                        height = Math.random() * 10 + 15;
                    } else {
                        // 20%は真上の位置（25〜40m）
                        height = Math.random() * 15 + 25;
                    }
                    
                    position.y = height;
                    attempts++;
                    
                    // 他のターゲットとの距離をチェック
                    let tooClose = false;
                    for (const placedPos of placedPositions) {
                        if (position.distanceTo(placedPos) < minDistance) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    if (tooClose && attempts < maxAttempts) continue;
                    
                    // 建物との衝突チェック
                    let insideBuilding = false;
                    for (const building of buildings) {
                        // 建物のバウンディングボックスを取得
                        const buildingBox = new THREE.Box3();
                        buildingBox.setFromObject(building);
                        
                        // バウンディングボックスを少し拡大（安全マージン）
                        buildingBox.expandByScalar(minBuildingDistance);
                        
                        // ターゲット位置がバウンディングボックス内にあるかチェック
                        if (buildingBox.containsPoint(position)) {
                            insideBuilding = true;
                            break;
                        }
                        
                        // より詳細なチェック：円形の建物の場合
                        const buildingCenter = new THREE.Vector3();
                        buildingBox.getCenter(buildingCenter);
                        const buildingSize = new THREE.Vector3();
                        buildingBox.getSize(buildingSize);
                        
                        // XZ平面での距離をチェック（円形の建物用）
                        const dx = position.x - buildingCenter.x;
                        const dz = position.z - buildingCenter.z;
                        const distance2D = Math.sqrt(dx * dx + dz * dz);
                        const buildingRadius = Math.max(buildingSize.x, buildingSize.z) / 2;
                        
                        // Y軸の範囲チェック
                        const yInRange = position.y >= buildingBox.min.y - minBuildingDistance && 
                                        position.y <= buildingBox.max.y + minBuildingDistance;
                        
                        if (yInRange && distance2D < buildingRadius + minBuildingDistance) {
                            insideBuilding = true;
                            break;
                        }
                    }
                    
                    if (insideBuilding && attempts < maxAttempts) continue;
                    
                    // スタート地点付近を避ける（プレイヤーの初期位置周辺）
                    const distanceFromStart = Math.sqrt(position.x * position.x + Math.pow(position.z - 85, 2));
                    if (distanceFromStart < 20 && attempts < maxAttempts * 0.8) continue;
                    
                    // すべての条件をクリアしたら配置
                    if (!tooClose && !insideBuilding || attempts >= maxAttempts) {
                        // 象限に記録
                        if (position.x < 0 && position.z > 0) {
                            quadrants.leftFront.push(position);
                        } else if (position.x > 0 && position.z > 0) {
                            quadrants.rightFront.push(position);
                        } else if (position.x < 0 && position.z < 0) {
                            quadrants.leftBack.push(position);
                        } else {
                            quadrants.rightBack.push(position);
                        }
                        break;
                    }
                } while (true);
                
                targetGroup.position.copy(position);
                placedPositions.push(position);
                
                targetGroup.userData = {
                    id: i,
                    hit: false,
                    hitRadius: 2.0,  // 外側のリング半径1.5 + トーラスの太さ0.15 + 余裕0.35（見た目とのマッチングを改善）
                    baseHitRadius: 2.0  // 元のヒット半径を保存
                };
                
                targets.push(targetGroup);
                scene.add(targetGroup);
            }
        }

        // 弾丸作成
        function createBullet() {
            const bulletGroup = new THREE.Group();
            
            // ワイヤーフレームの弾丸
            const bulletGeometry = new THREE.OctahedronGeometry(0.3, 0);
            const bulletMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000000,
                wireframe: true
            });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bulletGroup.add(bullet);
            
            // カメラの実際の視点位置を計算
            const cameraWorldPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraWorldPosition);
            
            // 画面中央に向かって正確にレイを飛ばす
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            // レイの方向を取得（これが画面中央への正確な方向）
            const direction = ray.ray.direction.clone().normalize();
            
            // 弾丸の初期位置をカメラの実際の位置に設定
            bulletGroup.position.copy(cameraWorldPosition);
            
            bulletGroup.userData = {
                velocity: direction.multiplyScalar(500), // 弾速を倍に（250→500）
                startTime: Date.now(),
                startPosition: bulletGroup.position.clone()
            };
            
            scene.add(bulletGroup);
            bullets.push(bulletGroup);
            
            return bulletGroup;
        }

        // パーティクル作成
        function createParticles(position) {
            for (let i = 0; i < 20; i++) {
                const particleGeometry = new THREE.TetrahedronGeometry(0.2);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    wireframe: true,
                    opacity: 1,
                    transparent: true
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 10,
                    (Math.random() - 0.5) * 10
                );
                
                particle.userData = {
                    velocity: velocity,
                    life: 1.0
                };
                
                particles.push(particle);
                scene.add(particle);
            }
        }

        // 射撃処理
        function shoot() {
            if (!isLocked) return;
            
            // 画面中央（クロスヘアの位置）から正確にレイを飛ばす
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            // 視覚的な弾丸を作成
            createBullet();
            flashCrosshair();
            
            // 射撃時の視覚的フィードバック
            createMuzzleFlash();
        }
        
        // マズルフラッシュエフェクト
        function createMuzzleFlash() {
            const flashGeometry = new THREE.OctahedronGeometry(1, 0);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                wireframe: true,
                opacity: 1,
                transparent: true
            });
            
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            
            // カメラの実際の位置から発射
            const cameraWorldPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraWorldPosition);
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            
            flash.position.copy(cameraWorldPosition);
            flash.position.add(cameraDirection.clone().multiplyScalar(1));
            
            scene.add(flash);
            
            // フェードアウトアニメーション
            let opacity = 1;
            function fadeOut() {
                opacity -= 0.1;
                flash.material.opacity = opacity;
                flash.scale.multiplyScalar(1.1);
                
                if (opacity > 0) {
                    requestAnimationFrame(fadeOut);
                } else {
                    scene.remove(flash);
                }
            }
            fadeOut();
        }

        // 弾丸の更新
        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bulletGroup = bullets[i];
                const bullet = bulletGroup.children[0];
                
                // 弾丸を直線的に移動
                const movement = bulletGroup.userData.velocity.clone().multiplyScalar(delta);
                
                // 移動前の位置を保存
                const startPos = bulletGroup.position.clone();
                
                // 建物との衝突判定（移動前にチェック）
                const bulletRay = new THREE.Raycaster(
                    bulletGroup.position,
                    bulletGroup.userData.velocity.clone().normalize(),
                    0,
                    movement.length()
                );
                
                const buildingIntersections = bulletRay.intersectObjects(buildings, true);
                if (buildingIntersections.length > 0) {
                    // 建物に衝突した場合
                    const hitPoint = buildingIntersections[0].point;
                    createBuildingHitEffect(hitPoint);
                    scene.remove(bulletGroup);
                    bullets.splice(i, 1);
                    continue;
                }
                
                // 衝突しなかった場合は移動
                bulletGroup.position.add(movement);
                
                // 弾丸を回転（視覚効果のため）
                bullet.rotation.x += 0.2;
                bullet.rotation.y += 0.1;
                
                // ターゲットとの衝突判定
                let hit = false;
                for (let j = 0; j < targets.length; j++) {
                    const target = targets[j];
                    if (!target.userData.hit) {
                        // まず、弾丸からターゲットまでの間に建物がないかチェック
                        const toTarget = target.position.clone().sub(bulletGroup.position);
                        const distanceToTarget = toTarget.length();
                        const directionToTarget = toTarget.normalize();
                        
                        const obstacleRay = new THREE.Raycaster(
                            bulletGroup.position,
                            directionToTarget,
                            0,
                            distanceToTarget
                        );
                        
                        const obstacleIntersections = obstacleRay.intersectObjects(buildings, true);
                        
                        // 建物が間にある場合はスキップ
                        if (obstacleIntersections.length > 0) {
                            continue;
                        }
                        
                        // より精密な判定のため、弾道を細かくチェック
                        // 移動距離に応じてチェック回数を調整
                        const moveDistance = startPos.distanceTo(bulletGroup.position);
                        const steps = Math.max(5, Math.ceil(moveDistance / 0.5)); // 0.5単位でチェック
                        
                        for (let step = 0; step <= steps; step++) {
                            const t = step / steps;
                            const checkPos = startPos.clone().lerp(bulletGroup.position, t);
                            const distance = checkPos.distanceTo(target.position);
                            
                            // ターゲットの現在のスケールを考慮したヒット半径
                            const currentScale = target.scale.x; // x, y, z は同じ値
                            const adjustedHitRadius = target.userData.baseHitRadius * currentScale;
                            
                            if (distance <= adjustedHitRadius) {
                                // 最終確認：チェック位置からターゲットまでの間に建物がないか
                                const finalCheck = new THREE.Raycaster(
                                    checkPos,
                                    target.position.clone().sub(checkPos).normalize(),
                                    0,
                                    distance
                                );
                                
                                const finalObstacles = finalCheck.intersectObjects(buildings, true);
                                if (finalObstacles.length === 0) {
                                    target.userData.hit = true;
                                    score++;
                                    updateUI();
                                    animateTargetHit(target);
                                    createParticles(target.position);
                                    
                                    scene.remove(bulletGroup);
                                    bullets.splice(i, 1);
                                    hit = true;
                                    
                                    if (score === 20) {
                                        showMessage("COMPLETE");
                                    }
                                    
                                    break;
                                }
                            }
                        }
                        
                        if (hit) break;
                    }
                }
                
                if (hit) continue;
                
                // 弾丸が遠くに行きすぎたら削除
                const travelDistance = bulletGroup.position.distanceTo(bulletGroup.userData.startPosition);
                if (travelDistance > 500 || Date.now() - bulletGroup.userData.startTime > 3000) {
                    scene.remove(bulletGroup);
                    bullets.splice(i, 1);
                }
            }
        }
        
        // 建物に弾が当たった時のエフェクト
        function createBuildingHitEffect(position) {
            // 小さなパーティクル効果
            for (let i = 0; i < 5; i++) {
                const particleGeometry = new THREE.TetrahedronGeometry(0.1);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0x333333,
                    wireframe: true,
                    opacity: 1,
                    transparent: true
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    Math.random() * 3,
                    (Math.random() - 0.5) * 3
                );
                
                particle.userData = {
                    velocity: velocity,
                    life: 0.5
                };
                
                particles.push(particle);
                scene.add(particle);
            }
        }

        // パーティクル更新
        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                particle.position.add(particle.userData.velocity.clone().multiplyScalar(delta));
                particle.userData.velocity.y -= 20 * delta; // 重力
                
                particle.rotation.x += 0.1;
                particle.rotation.y += 0.1;
                
                particle.userData.life -= delta * 2;
                particle.material.opacity = particle.userData.life;
                
                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    particles.splice(i, 1);
                }
            }
        }

        // ターゲットヒットアニメーション
        function animateTargetHit(target) {
            const startPos = target.position.clone();
            const startScale = target.scale.x; // 現在のスケールを保存
            let progress = 0;
            
            function animate() {
                progress += 0.03;
                
                if (progress < 1) {
                    // 螺旋状に上昇しながら消える（的が小さくなったので広がりも調整）
                    const angle = progress * Math.PI * 4;
                    target.position.x = startPos.x + Math.cos(angle) * progress * 3;
                    target.position.y = startPos.y + progress * 10; // 上昇距離を調整
                    target.position.z = startPos.z + Math.sin(angle) * progress * 3;
                    
                    target.rotation.x += 0.2;
                    target.rotation.y += 0.2;
                    target.rotation.z += 0.2;
                    
                    target.scale.setScalar(startScale * (1 - progress));
                    
                    // ワイヤーフレームの透明度
                    target.traverse((child) => {
                        if (child.material) {
                            child.material.opacity = 1 - progress;
                            child.material.transparent = true;
                        }
                    });
                    
                    requestAnimationFrame(animate);
                } else {
                    scene.remove(target);
                }
            }
            
            animate();
        }

        // クロスヘアフラッシュ
        function flashCrosshair() {
            const crosshair = document.getElementById('crosshair');
            crosshair.style.transform = 'translate(-50%, -50%) scale(1.5)';
            setTimeout(() => {
                crosshair.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 100);
        }

        // マウス移動処理
        function onMouseMove(event) {
            if (!isLocked) return;
            
            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            
            yawObject.rotation.y -= movementX * 0.002;
            pitchObject.rotation.x -= movementY * 0.002;
            
            pitchObject.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchObject.rotation.x));
        }

        // マウスボタン押下
        let isMouseDown = false;
        function onMouseDown(event) {
            if (event.button === 0) {
                isMouseDown = true;
            }
        }

        function onMouseUp(event) {
            if (event.button === 0 && isMouseDown) {
                isMouseDown = false;
                shoot();
            }
        }

        // キー押下処理
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'KeyQ':
                    turnLeft = true;
                    break;
                case 'KeyE':
                    turnRight = true;
                    break;
                case 'Space':
                    if (canJump) velocity.y = 8; // ジャンプ力を調整
                    canJump = false;
                    break;
            }
        }

        // キー離上処理
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'KeyQ':
                    turnLeft = false;
                    break;
                case 'KeyE':
                    turnRight = false;
                    break;
            }
        }

        // ウィンドウリサイズ処理
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // UI更新
        function updateUI() {
            document.getElementById('score').textContent = score;
        }

        // タイマー開始
        function startTimer() {
            if (!isGameRunning) {
                isGameRunning = true;
                startTime = Date.now();
                timerInterval = setInterval(updateTimer, 100);
            }
        }

        // タイマー停止
        function stopTimer() {
            if (isGameRunning) {
                isGameRunning = false;
                clearInterval(timerInterval);
            }
        }

        // タイマー更新
        function updateTimer() {
            if (isGameRunning) {
                elapsedTime = Math.floor((Date.now() - startTime) / 1000);
                const minutes = Math.floor(elapsedTime / 60);
                const seconds = elapsedTime % 60;
                const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('timer').textContent = timeString;
            }
        }

        // メッセージ表示
        function showMessage(text) {
            const messageEl = document.getElementById('message');
            messageEl.innerHTML = ''; // 内容をクリア
            
            // COMPLETEの場合
            if (text === "COMPLETE") {
                stopTimer(); // タイマーを停止
                
                // メインメッセージ
                const mainText = document.createElement('div');
                mainText.textContent = 'COMPLETE';
                mainText.style.marginBottom = '20px';
                messageEl.appendChild(mainText);
                
                // クリアタイム表示
                const minutes = Math.floor(elapsedTime / 60);
                const seconds = elapsedTime % 60;
                const timeText = document.createElement('div');
                timeText.textContent = `CLEAR TIME: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                timeText.style.fontSize = '24px';
                timeText.style.fontWeight = '300';
                timeText.style.letterSpacing = '4px';
                timeText.style.marginBottom = '30px';
                messageEl.appendChild(timeText);
                
                // NEW GAMEボタン
                const newGameBtn = document.createElement('button');
                newGameBtn.textContent = 'NEW GAME';
                newGameBtn.style.cssText = `
                    display: block;
                    margin: 0 auto;
                    padding: 15px 40px;
                    font-size: 18px;
                    font-weight: 100;
                    letter-spacing: 4px;
                    background: #000;
                    color: #fff;
                    border: none;
                    cursor: pointer;
                    transition: all 0.3s;
                    font-family: 'Inter', sans-serif;
                    text-transform: uppercase;
                `;
                
                // hover効果を削除
                
                newGameBtn.onclick = function() {
                    resetGame();
                };
                
                messageEl.appendChild(newGameBtn);
            } else {
                messageEl.textContent = text;
            }
            
            messageEl.style.display = 'block';
        }
        
        // ゲームリセット
        function resetGame() {
            // メッセージを非表示
            const messageEl = document.getElementById('message');
            messageEl.style.display = 'none';
            messageEl.innerHTML = '';
            
            // スコアをリセット
            score = 0;
            updateUI();
            
            // タイマーをリセット
            stopTimer();
            elapsedTime = 0;
            document.getElementById('timer').textContent = '00:00';
            
            // 既存のターゲットを削除
            targets.forEach(target => {
                scene.remove(target);
            });
            targets = [];
            
            // 既存の弾丸を削除
            bullets.forEach(bullet => {
                scene.remove(bullet);
            });
            bullets = [];
            
            // 既存のパーティクルを削除
            particles.forEach(particle => {
                scene.remove(particle);
            });
            particles = [];
            
            // 建物リストはクリアしない（アトラクションは残るため）
            
            // 新しいターゲットを作成（建物との衝突を考慮）
            createTargets();
            
            // プレイヤーを初期位置に戻す
            yawObject.position.set(0, 1.6, 85);
            yawObject.rotation.y = 0;
            pitchObject.rotation.x = 0;
            totalYawRotation = 0;
            totalPitchRotation = 0;
            
            // タイマーを再開
            startTimer();
        }

        // アトラクションのアニメーション
        function animateAttractions() {
            // 観覧車
            if (animatedObjects.ferrisWheel && animatedObjects.ferrisWheel.userData.wheelGroup) {
                const wheelGroup = animatedObjects.ferrisWheel.userData.wheelGroup;
                wheelGroup.rotation.z += 0.003;
                
                // ゴンドラを水平に保つ
                wheelGroup.children.forEach(child => {
                    if (child.userData && child.userData.rotation !== undefined) {
                        child.rotation.z = -wheelGroup.rotation.z;
                    }
                });
            }

            // メリーゴーランド
            if (animatedObjects.merryGoRound) {
                animatedObjects.merryGoRound.rotation.y += 0.005;  // さらに速度を遅く
                
                // 馬のアニメーション
                animatedObjects.merryGoRound.children.forEach(child => {
                    if (child.userData.angle !== undefined) {
                        const offset = Math.sin(Date.now() * 0.002 + child.userData.angle) * 0.7;
                        child.position.y = child.userData.baseY + offset;
                    }
                });
            }

            // ローラーコースター（改良されたアニメーション）
            if (animatedObjects.rollerCoaster) {
                animatedObjects.rollerCoaster.children.forEach(child => {
                    if (child.userData.curve && child.userData.trainIndex !== undefined) {
                        child.userData.progress += 0.0011 + (child.userData.trainIndex * 0.00055);  // スピードを少し速く
                        if (child.userData.progress > 1) child.userData.progress = 0;
                        
                        const curve = child.userData.curve;
                        const point = curve.getPoint(child.userData.progress);
                        const tangent = curve.getTangent(child.userData.progress);
                        
                        // カートをレールの上に正確に配置（レールの半径とカートの車輪を考慮）
                        child.position.copy(point);
                        child.position.y += 0.5;  // レールの半径（0.15）+ カートの車輪半径（0.3）+ 少しの余裕
                        
                        // 正しい向きを計算（線路の傾斜に沿わせる）
                        // 次のポイントを取得して上方向ベクトルを計算
                        const nextProgress = Math.min(child.userData.progress + 0.001, 1);
                        const nextPoint = curve.getPoint(nextProgress);
                        
                        // カートの向きを設定するための行列を作成
                        const matrix = new THREE.Matrix4();
                        const up = new THREE.Vector3(0, 1, 0);
                        
                        // 進行方向
                        const forward = tangent.clone().normalize();
                        
                        // 右方向を計算
                        const right = new THREE.Vector3().crossVectors(forward, up).normalize();
                        
                        // 実際の上方向を再計算（線路の傾斜を考慮）
                        const actualUp = new THREE.Vector3().crossVectors(right, forward).normalize();
                        
                        // 回転行列を設定
                        matrix.makeBasis(right, actualUp, forward.multiplyScalar(-1));
                        child.rotation.setFromRotationMatrix(matrix);
                        
                        // 編成内のカート間の距離を調整
                        if (child.userData.carIndex > 0) {
                            const offset = child.userData.carIndex * 0.02;
                            let adjustedProgress = child.userData.progress - offset;
                            if (adjustedProgress < 0) adjustedProgress += 1;
                            
                            const adjustedPoint = curve.getPoint(adjustedProgress);
                            const adjustedTangent = curve.getTangent(adjustedProgress);
                            child.position.copy(adjustedPoint);
                            child.position.y += 0.5;  // 同じオフセットを適用
                            
                            // 調整されたカートの向きも同様に計算
                            const adjustedForward = adjustedTangent.clone().normalize();
                            const adjustedRight = new THREE.Vector3().crossVectors(adjustedForward, up).normalize();
                            const adjustedActualUp = new THREE.Vector3().crossVectors(adjustedRight, adjustedForward).normalize();
                            
                            const adjustedMatrix = new THREE.Matrix4();
                            adjustedMatrix.makeBasis(adjustedRight, adjustedActualUp, adjustedForward.multiplyScalar(-1));
                            child.rotation.setFromRotationMatrix(adjustedMatrix);
                        }
                    }
                });
            }

            // スイングライド
            if (animatedObjects.swingRide) {
                const rotatingHub = animatedObjects.swingRide.userData.rotatingHub;
                if (rotatingHub) {
                    // ハブ全体の回転
                    rotatingHub.rotation.y += 0.006;
                    
                    // スイングコンテナの取得
                    const swingContainer = rotatingHub.userData.swingContainer;
                    if (swingContainer) {
                        swingContainer.children.forEach(swingGroup => {
                            if (swingGroup.userData.chainGroup) {
                                const chainGroup = swingGroup.userData.chainGroup;
                                const baseAngle = swingGroup.userData.baseAngle;
                                
                                // 遠心力による外側への傾き
                                const centrifugalForce = 0.4; // 遠心力の強さ（少し弱めに調整）
                                const oscillation = Math.sin(Date.now() * 0.0008 + baseAngle) * 0.05;
                                
                                // チェーンの傾き
                                chainGroup.rotation.z = centrifugalForce + oscillation;
                                
                                // 個々のチェーンリンクの微妙な動き
                                chainGroup.children.forEach((child, index) => {
                                    if (child.type === 'Mesh' && child.geometry.type === 'TorusGeometry') {
                                        // チェーンリンクの微妙な揺れ
                                        child.rotation.x += Math.sin(Date.now() * 0.002 + index * 0.1) * 0.01;
                                    }
                                });
                            }
                        });
                    }
                    
                    // フラッグのアニメーション
                    animatedObjects.swingRide.children.forEach(child => {
                        if (child.userData.baseAngle !== undefined && child.type === 'Line') {
                            const waveAmount = Math.sin(Date.now() * 0.003 + child.userData.baseAngle) * 0.1;
                            child.rotation.y = child.userData.baseAngle + waveAmount;
                            child.rotation.z = waveAmount * 0.5;
                        }
                    });
                }
            }

            // フリーフォール
            if (animatedObjects.freeFall) {
                const platform = animatedObjects.freeFall.children.find(child => child.userData.baseY !== undefined);
                if (platform) {
                    // 時間に基づくサイクル（1サイクル = 10秒）
                    const cycleTime = (Date.now() % 10000) / 10000; // 0から1の値
                    
                    let progress;
                    if (cycleTime < 0.4) {
                        // 上昇フェーズ（ゆっくり：全体の40%の時間）
                        progress = cycleTime / 0.4; // 0から1へ
                    } else if (cycleTime < 0.5) {
                        // 頂点での一時停止（全体の10%の時間）
                        progress = 1;
                    } else if (cycleTime < 0.58) {
                        // 落下フェーズ（さらに速い：全体の8%の時間）
                        progress = 1 - ((cycleTime - 0.5) / 0.08); // 1から0へ超急速に
                    } else {
                        // 下での待機（全体の42%の時間）
                        progress = 0;
                    }
                    
                    platform.position.y = platform.userData.baseY + progress * 30;
                }
            }

            // バイキングシップ（改良されたアニメーション）
            if (animatedObjects.vikingShip) {
                const shipGroup = animatedObjects.vikingShip.userData.shipGroup;
                if (shipGroup) {
                    shipGroup.userData.swingAngle = Math.sin(Date.now() * 0.0008) * 0.65;
                    shipGroup.rotation.z = shipGroup.userData.swingAngle;
                }
            }

            // ティーカップ
            if (animatedObjects.teacups) {
                animatedObjects.teacups.rotation.y += 0.005;
                
                animatedObjects.teacups.children.forEach(child => {
                    if (child.userData.spinSpeed) {
                        child.rotation.y += child.userData.spinSpeed;
                    }
                });
            }

            // ゴーカート（改良されたアニメーション）
            if (animatedObjects.goKarts) {
                animatedObjects.goKarts.children.forEach(child => {
                    if (child.userData.curve && child.userData.lane !== undefined) {
                        child.userData.progress += 0.0015 + (child.userData.lane * 0.000375);  // スピードを少し速く
                        if (child.userData.progress > 1) child.userData.progress = 0;
                        
                        const point = child.userData.curve.getPoint(child.userData.progress);
                        const tangent = child.userData.curve.getTangent(child.userData.progress);
                        
                        // レーンオフセット
                        const laneOffset = child.userData.lane === 0 ? -1 : 1;
                        const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
                        point.add(normal.multiplyScalar(laneOffset));
                        
                        child.position.copy(point);
                        child.position.y = 0.5;
                        child.lookAt(point.clone().add(tangent));
                        
                        // ホイールの回転
                        child.children.forEach(part => {
                            if (part.children && part.children.length > 0) {
                                part.children.forEach(wheel => {
                                    if (wheel.rotation) {
                                        wheel.rotation.x += 0.2;
                                    }
                                });
                            }
                        });
                    }
                });
            }

            // ミニトレイン（改良されたアニメーション）
            if (animatedObjects.trainTrack) {
                const train = animatedObjects.trainTrack.children.find(child => child.userData.curve);
                if (train) {
                    train.userData.progress += 0.0004;  // 速度を半分に
                    if (train.userData.progress > 1) train.userData.progress = 0;
                    
                    const point = train.userData.curve.getPoint(train.userData.progress);
                    const tangent = train.userData.curve.getTangent(train.userData.progress);
                    
                    train.position.copy(point);
                    train.lookAt(point.clone().add(tangent));
                    
                    // 機関車の車輪を回転
                    if (train.children[0]) { // 機関車
                        train.children[0].children.forEach(part => {
                            if (part.geometry && part.geometry.type === 'CylinderGeometry' && 
                                part.position.y < 1) { // 車輪の判定
                                part.rotation.x += 0.1;
                            }
                        });
                    }
                }
            }

            // 月の回転
            scene.children.forEach(child => {
                if (child.userData.rotationSpeed) {
                    child.rotation.y += child.userData.rotationSpeed;
                }
            });

            // 星のきらめき
            scene.children.forEach(child => {
                if (child.userData.isStar && child.userData.twinkleOffset !== undefined) {
                    const twinkle = Math.sin(Date.now() * child.userData.twinkleSpeed + child.userData.twinkleOffset);
                    child.material.opacity = child.material.opacity * 0.7 + twinkle * 0.3;
                    child.rotation.x += 0.005;
                    child.rotation.y += 0.005;
                }
            });

            // 星座のアニメーション
            if (animatedObjects.constellations) {
                animatedObjects.constellations.children.forEach((constellation, i) => {
                    if (constellation.userData.animSpeed) {
                        // ゆっくりとした回転（天頂の星座は異なる回転）
                        if (constellation.rotation.x === -Math.PI / 2) {
                            // 天頂の星座は水平回転
                            constellation.rotation.y = Date.now() * 0.0001 * constellation.userData.animSpeed;
                        } else {
                            // 通常の星座
                            constellation.rotation.z = constellation.userData.baseRotationZ + 
                                Math.sin(Date.now() * 0.0001 * constellation.userData.animSpeed) * 0.05;
                        }
                        
                        // 星座内の星の明滅
                        constellation.children.forEach(child => {
                            if (child.material && child.userData.twinkleOffset !== undefined) {
                                const baseMaterial = child.material;
                                if (!baseMaterial.baseOpacity) {
                                    baseMaterial.baseOpacity = baseMaterial.opacity;
                                }
                                const twinkle = Math.sin(Date.now() * child.userData.twinkleSpeed + child.userData.twinkleOffset);
                                baseMaterial.opacity = baseMaterial.baseOpacity * (0.7 + twinkle * 0.3);
                            }
                        });
                    }
                });
            }

            // ペンデュラムライド
            if (animatedObjects.pendulumRide) {
                const pendulumArm = animatedObjects.pendulumRide.userData.pendulumArm;
                if (pendulumArm) {
                    // 振り子の動き（最大120度まで振れる）
                    pendulumArm.userData.swingAngle = Math.sin(Date.now() * 0.0006) * (Math.PI * 2 / 3);
                    pendulumArm.rotation.z = pendulumArm.userData.swingAngle;
                    
                    // 座席プラットフォームの回転
                    const seatPlatform = pendulumArm.userData.seatPlatform;
                    if (seatPlatform) {
                        // 振り子の角度に応じて回転速度を変える
                        const rotationSpeed = Math.abs(pendulumArm.userData.swingAngle) * 0.02;
                        seatPlatform.rotation.y += rotationSpeed;
                    }
                }
            }
            
            // 巨大振り子時計塔
            if (animatedObjects.clockTower) {
                const clockMechanism = animatedObjects.clockTower.userData.clockMechanism;
                if (clockMechanism) {
                    // 歯車の回転
                    const gearSystem = clockMechanism.userData.gearSystem;
                    if (gearSystem) {
                        gearSystem.children.forEach(gear => {
                            if (gear.userData.rotationSpeed) {
                                gear.rotation.z += gear.userData.rotationSpeed;
                            }
                        });
                    }
                    
                    // 振り子の動き
                    const pendulumArm = clockMechanism.children.find(child => 
                        child.userData && child.userData.pendulumArm
                    );
                    if (pendulumArm) {
                        const arm = pendulumArm.userData.pendulumArm;
                        arm.rotation.z = Math.sin(Date.now() * 0.001) * 0.2; // ゆっくりとした振り子運動
                    }
                    
                    // 時計の針の動き
                    const clockFace = clockMechanism.children.find(child => child.type === 'Group');
                    if (clockFace) {
                        clockFace.children.forEach(child => {
                            if (child.userData.isMinuteHand) {
                                child.rotation.z = -(Date.now() * 0.0001) % (Math.PI * 2);
                            }
                            if (child.userData.isHourHand) {
                                child.rotation.z = -(Date.now() * 0.0001 / 12) % (Math.PI * 2);
                            }
                        });
                    }
                }
                
                // チャイムの演出（毎分）
                const bellSystem = animatedObjects.clockTower.userData.bellSystem;
                if (bellSystem) {
                    const currentMinute = Math.floor(Date.now() / 60000);
                    if (currentMinute !== bellSystem.userData.lastChimeTime) {
                        bellSystem.userData.lastChimeTime = currentMinute;
                        
                        // ベルを揺らす演出
                        bellSystem.children.forEach(bell => {
                            if (bell.userData.isChimeBell) {
                                // 一時的に揺れる演出を追加
                                const originalRotation = bell.rotation.x;
                                let swingCount = 0;
                                const swingBell = () => {
                                    if (swingCount < 30) {
                                        bell.rotation.x = originalRotation + Math.sin(swingCount * 0.5) * 0.2;
                                        swingCount++;
                                        requestAnimationFrame(swingBell);
                                    } else {
                                        bell.rotation.x = originalRotation;
                                    }
                                };
                                swingBell();
                            }
                        });
                    }
                }
            }
        }

        // アニメーションループ
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            
            // 移動処理
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= 20 * delta; // 重力を軽くする
            
            // キーボードでの回転処理
            if (turnLeft) {
                totalYawRotation += 3 * delta; // 秒間約3ラジアン回転
                yawObject.rotation.y = totalYawRotation;
            }
            if (turnRight) {
                totalYawRotation -= 3 * delta; // 秒間約3ラジアン回転
                yawObject.rotation.y = totalYawRotation;
            }
            
            // 視点の向いている方向を基準とした移動
            const moveVector = new THREE.Vector3();
            
            if (moveForward || moveBackward) {
                const forwardDirection = new THREE.Vector3(0, 0, -1); // カメラの前方向
                forwardDirection.applyQuaternion(yawObject.quaternion);
                const forwardMovement = forwardDirection.multiplyScalar(
                    (Number(moveForward) - Number(moveBackward)) * 50.0 * delta  // 速度を半分に
                );
                moveVector.add(forwardMovement);
            }
            
            if (moveLeft || moveRight) {
                const rightDirection = new THREE.Vector3(1, 0, 0); // カメラの右方向
                rightDirection.applyQuaternion(yawObject.quaternion);
                const rightMovement = rightDirection.multiplyScalar(
                    (Number(moveRight) - Number(moveLeft)) * 50.0 * delta  // 速度を半分に
                );
                moveVector.add(rightMovement);
            }
            
            // Y軸（垂直）の移動は別途処理
            moveVector.y = velocity.y * delta;
            
            // 新しい位置を計算
            const newPosition = yawObject.position.clone().add(moveVector);
            
            // 衝突判定を無効化（アトラクションをすり抜け可能）
            let canMove = true;
            
            // フィールドの境界チェック（グリッドは200x200なので、-95〜95の範囲に制限）
            const fieldBoundary = 95;
            if (Math.abs(newPosition.x) <= fieldBoundary && Math.abs(newPosition.z) <= fieldBoundary) {
                yawObject.position.copy(newPosition);
            } else {
                // 境界を超える場合は、境界内で移動できる分だけ移動
                if (Math.abs(newPosition.x) > fieldBoundary) {
                    newPosition.x = Math.sign(newPosition.x) * fieldBoundary;
                }
                if (Math.abs(newPosition.z) > fieldBoundary) {
                    newPosition.z = Math.sign(newPosition.z) * fieldBoundary;
                }
                
                // 位置を更新（アトラクションをすり抜け可能）
                yawObject.position.x = newPosition.x;
                yawObject.position.z = newPosition.z;
                yawObject.position.y = newPosition.y;
            }
            
            if (yawObject.position.y < 1.6) {
                velocity.y = 0;
                yawObject.position.y = 1.6;
                canJump = true;
                
                // 着地時も境界チェック
                const fieldBoundary = 95;
                if (Math.abs(yawObject.position.x) > fieldBoundary) {
                    yawObject.position.x = Math.sign(yawObject.position.x) * fieldBoundary;
                }
                if (Math.abs(yawObject.position.z) > fieldBoundary) {
                    yawObject.position.z = Math.sign(yawObject.position.z) * fieldBoundary;
                }
            }
            
            // ターゲットをカメラ方向に向ける（ビルボード効果）
            targets.forEach((target) => {
                if (!target.userData.hit) {
                    // カメラの方向を向かせる前の回転を保存
                    const originalRotation = target.rotation.clone();
                    
                    const cameraWorldPosition = new THREE.Vector3();
                    camera.getWorldPosition(cameraWorldPosition);
                    
                    target.lookAt(cameraWorldPosition);
                    // Y軸の回転のみ保持（上下に傾かないようにする）
                    target.rotation.x = 0;
                    target.rotation.z = 0;
                    
                    // 衝突判定用に元の向きを保存
                    target.userData.billboardRotation = target.rotation.y;
                    
                    // 距離に応じてサイズを調整
                    const distance = target.position.distanceTo(cameraWorldPosition);
                    // 基本スケール: 距離5mで0.5倍、距離50m以上で1.0倍
                    const minDistance = 5;
                    const maxDistance = 50;
                    const minScale = 0.5;
                    const maxScale = 1.0;
                    
                    let scale;
                    if (distance <= minDistance) {
                        scale = minScale;
                    } else if (distance >= maxDistance) {
                        scale = maxScale;
                    } else {
                        // 線形補間
                        const t = (distance - minDistance) / (maxDistance - minDistance);
                        scale = minScale + t * (maxScale - minScale);
                    }
                    
                    target.scale.setScalar(scale);
                    
                    // ゆっくり回転させて視認性を向上
                    target.children.forEach((child, index) => {
                        if (index === 0) child.rotation.z += 0.01;  // 外側のリング
                        if (index === 1) child.rotation.z -= 0.015; // 中間のリング
                        if (index === 2) {  // 内側の八面体
                            child.rotation.x += 0.02;
                            child.rotation.y += 0.02;
                        }
                    });
                }
            });
            
            updateBullets(delta);
            updateParticles(delta);
            animateAttractions();
            
            prevTime = time;
            
            renderer.render(scene, camera);
        }

        // ゲーム開始
        init();
        animate();
    </script>
</body>
</html>
